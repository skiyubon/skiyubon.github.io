{"meta":{"title":"Skiyubon's\tBlog","subtitle":null,"description":null,"author":"WUZHOU","url":"https://skiyubon.github.io"},"pages":[{"title":"","date":"2018-04-04T08:30:50.039Z","updated":"2017-04-11T07:07:18.541Z","comments":true,"path":"baidu_verify_Prh1Mfyebr.html","permalink":"https://skiyubon.github.io/baidu_verify_Prh1Mfyebr.html","excerpt":"","text":"Prh1Mfyebr"},{"title":"about","date":"2017-04-11T01:34:42.000Z","updated":"2017-04-18T01:38:26.085Z","comments":true,"path":"about/index.html","permalink":"https://skiyubon.github.io/about/index.html","excerpt":"","text":"诚挚说明：本博客完全是由个人自学计算机软件技术笔记之用，不做任何商业用途。文章所引用之处，也不作任何商业用途。 Email：wuzhou_personal@163.com"},{"title":"categories","date":"2017-04-11T00:46:51.000Z","updated":"2017-04-11T00:48:33.517Z","comments":true,"path":"categories/index.html","permalink":"https://skiyubon.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-10T15:56:55.000Z","updated":"2017-04-10T15:58:10.925Z","comments":true,"path":"tags/index.html","permalink":"https://skiyubon.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"spring-boot","slug":"spring-boot","date":"2018-04-09T06:36:23.000Z","updated":"2018-04-09T07:02:58.925Z","comments":true,"path":"2018/04/09/spring-boot/","link":"","permalink":"https://skiyubon.github.io/2018/04/09/spring-boot/","excerpt":"","text":"spring-bootSpring Boot可以轻松创建独立的，生产级的基于Spring的应用程序，您可以“运行”。我们对Spring平台和第三方库有自己的看法，所以您可以尽量少用大惊小怪。大多数Spring Boot应用程序只需要很少的Spring配置。 特征 创建独立的Spring应用程序 直接嵌入Tomcat，Jetty或Undertow（无需部署WAR文件） 提供自己的’入门’POM来简化你的Maven配置 尽可能自动配置Spring 提供生产就绪功能，如指标，运行状况检查和外部配置 绝对不会生成代码，并且不需要XML配置 部署到云Spring Boot的灵活打包选项在部署应用程序时提供了大量选择。您可以将Spring Boot应用程序部署到各种云平台，容器映像（如Docker）或虚拟/真实机器。Spring Boot的可执行程序jar已经为大多数流行的云PaaS（平台即服务）提供商准备好了。这些提供者往往要求你“携带你自己的容器”。他们管理应用程序进程（特别是Java应用程序），因此他们需要一个中间层，使您的应用程序 适应云对正在运行的进程的概念。两个流行的云提供商Heroku和Cloud Foundry采用“buildpack”方法。buildpack将您部署的代码封装在启动应用程序所需的任何代码中。它可能是一个JDK和一个调用java，一个嵌入式Web服务器或一个成熟的应用程序服务器。buildpack是可插入的，但理想情况下，您应该能够尽可能少地进行自定义。这减少了不受您控制的功能的占用空间。它最大限度地减少了开发和生产环境之间的差异。理想情况下，您的应用程序就像Spring Boot可执行程序jar一样，具有打包的所有内容。 实践 目前项目中,没有使用直接嵌入Tomcat,还是打war包并部署到Tomcat中.不过,如果没有指定其他buildpack，Cloud Foundry会提供默认构建包。Cloud Foundry Java buildpack对Spring应用程序（包括Spring Boot）提供了出色的支持。您可以部署独立的可执行jar应用程序以及传统的.war打包应用程序。 用到了Spring-boot的自动配置特性.","categories":[],"tags":[{"name":"spring-boot","slug":"spring-boot","permalink":"https://skiyubon.github.io/tags/spring-boot/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-04-04T03:05:49.209Z","updated":"2018-04-04T03:05:49.209Z","comments":true,"path":"2018/04/04/hello-world/","link":"","permalink":"https://skiyubon.github.io/2018/04/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"oop","slug":"oop","date":"2018-04-04T01:48:06.000Z","updated":"2018-04-04T02:21:01.110Z","comments":true,"path":"2018/04/04/oop/","link":"","permalink":"https://skiyubon.github.io/2018/04/04/oop/","excerpt":"","text":"面向对象思想 过程式编程:在问题和计算机做关联与实现. 面向对象编程:将思想解放出来,直接只面对问题建模,而不用考虑计算机,简化问题.分析问题空间,就是在清晰问题中的元素和对象.解问题可以直接表现为对象. java oop 由Simtalk演化 Oject java和多数的oop language都是单根继承,简单.除c++,是多继承,更灵活,但也有弊端,多义复杂. 对象在整个系统中具有唯一性标识,脱离了整个系统就不一定.hashCode() java对象支持多线程 wait() notify() Class 一些共性对象可以分门别类到一起,具有共性的属性或者行为,抽象出来就类. 类和语言的基本数据类型平级. 基本数据类型可以被变量引用,并在内存中占据一定物理空间,类也是一样.类的这种变量引用叫做实例化,也叫创建了属于类的一个对象. extends 提供类的复用性,不用每次都新建类. 类的继承,使类之间有了关系,基类具有更共性的属性或者行为,而导出类则在基类的基础上表现出增量的或者更加特性的行为.(新增方法和重写基类的方法) 继承一定是类之间本身就是is-a 或 like-a的关系 组合是一个has-a的关系,继承和组合用于不同的关系,不要互相借用. interface","categories":[],"tags":[{"name":"OOP","slug":"OOP","permalink":"https://skiyubon.github.io/tags/OOP/"}]},{"title":"元数据驱动设计","slug":"元数据驱动设计","date":"2017-07-17T02:15:07.000Z","updated":"2017-07-17T06:46:50.375Z","comments":true,"path":"2017/07/17/元数据驱动设计/","link":"","permalink":"https://skiyubon.github.io/2017/07/17/元数据驱动设计/","excerpt":"","text":"背景虽然关于使用数据文件的争议还在继续，但当今世界对于实时信息的渴望却一天比一天强烈，而通过API的方式进行数据检索的这种实践越来越多地开始满足人们的这种渴望。在今后的许多年中，遗留程序与系统仍将从文件中获取数据，但这些系统最终很可能会因为干系人对实时数据的渴望而被取代。当然，为了让这种转变成功地实现，我们还需要新的系统与程序。此外，由于这种方式不会再将数据进行压缩并归档至某个目标文件夹，因此我们必须创建一种自己的数据保留方案。 什么是元数据驱动设计实际上，我们在这种情况下可以使用元数据驱动设计以创建一种健壮的架构，它能够承担并执行这些我们所期望的职责。那么，到底元数据驱动设计是什么呢？为了简洁起见，可以将它简单地归结为一种软件设计与实现的途径，让元数据组成并集成这两个开发阶段。换句话说，在这种方式下，开发者能够在整个软件开发的生命周期3中采取敏捷式的迭代。通过使用由领域驱动设计所派生的元数据，你可以进而进行下一步的元数据驱动设计，并且创建出令人印象深刻的灵活架构。","categories":[],"tags":[{"name":"软件设计","slug":"软件设计","permalink":"https://skiyubon.github.io/tags/软件设计/"}]},{"title":"Spring 容器","slug":"Spring-容器","date":"2017-07-10T08:14:04.000Z","updated":"2017-07-10T08:15:30.287Z","comments":true,"path":"2017/07/10/Spring-容器/","link":"","permalink":"https://skiyubon.github.io/2017/07/10/Spring-容器/","excerpt":"","text":"","categories":[{"name":"Java","slug":"Java","permalink":"https://skiyubon.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://skiyubon.github.io/tags/Spring/"}]},{"title":"fastjson","slug":"fastjson","date":"2017-06-26T03:49:07.000Z","updated":"2017-06-27T02:11:43.251Z","comments":true,"path":"2017/06/26/fastjson/","link":"","permalink":"https://skiyubon.github.io/2017/06/26/fastjson/","excerpt":"Fastjson是一个Java语言编写的高性能功能完善的JSON库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致，是目前Java语言中最快的JSON库。Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、Web输出、Android客户端等多种应用场景。","text":"Fastjson是一个Java语言编写的高性能功能完善的JSON库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致，是目前Java语言中最快的JSON库。Fastjson接口简单易用，已经被广泛使用在缓存序列化、协议交互、Web输出、Android客户端等多种应用场景。 #fastjson主要的APIfastjson入口类是com.alibaba.fastjson.JSON，主要的API是JSON.toJSONString，和parseObject。 package com.alibaba.fastjson; public abstract class JSON { public static final String toJSONString(Object object); public static final &lt;T&gt; T parseObject(String text, Class&lt;T&gt; clazz, Feature... features); } fastjson如何处理日期 fastjson处理日期的API很简单，例如： JSON.toJSONStringWithDateFormat(date, &quot;yyyy-MM-dd HH:mm:ss.SSS&quot;) 使用ISO-8601日期格式 JSON.toJSONString(obj, SerializerFeature.UseISO8601DateFormat); 全局修改日期格式 JSON.DEFFAULT_DATE_FORMAT = &quot;yyyy-MM-dd&quot;; JSON.toJSONString(obj, SerializerFeature.WriteDateUseDateFormat); 反序列化能够自动识别如下日期格式： ISO-8601日期格式 yyyy-MM-dd yyyy-MM-dd HH:mm:ss yyyy-MM-dd HH:mm:ss.SSS 毫秒数字 毫秒数字字符串 .NET JSON日期格式 new Date(198293238) 如何定制序列化？使用SimplePropertyPreFilter过滤属性需要根据不同的环境返回定制化返回属性时，可以使用SimplePropertyPreFilter。 SimplePropertyPreFilter接口public class SimplePropertyPreFilter implements PropertyPreFilter { public SimplePropertyPreFilter(String... properties){ this(null, properties); } public SimplePropertyPreFilter(Class&lt;?&gt; clazz, String... properties){ // ... ... } public Class&lt;?&gt; getClazz() { return clazz; } public Set&lt;String&gt; getIncludes(); public Set&lt;String&gt; getExcludes(); /** * @since 1.2.9 */ public int getMaxLevel(); /** * @since 1.2.9 */ public void setMaxLevel(int maxLevel) //... } 你可以配置includes、excludes。当class不为null时，针对特定类型；当class为null时，针对所有类型。 当includes的size &gt; 0时，属性必须在includes中才会被序列化，excludes优先于includes。 Class_Level_SerializeFilter对于框架来说，如果在toJSONString的时候，传入SerializeFilter，会导致对所有的类型做过滤，性能会受到一定影响。在1.2.10版本之后，fastjson提供类级别的SerializeFilter支持。 package com.alibaba.fastjson.serializer; public class SerializeConfig { public void addFilter(Class&lt;?&gt; clazz, SerializeFilter filter); } Sample public class ClassNameFilterTest extends TestCase { public void test_filter() throws Exception { NameFilter upcaseNameFilter = new NameFilter() { public String process(Object object, String name, Object value) { return name.toUpperCase(); } }; SerializeConfig.getGlobalInstance() // .addFilter(A.class, upcaseNameFilter); Assert.assertEquals(&quot;{\\&quot;ID\\&quot;:0}&quot;, JSON.toJSONString(new A())); Assert.assertEquals(&quot;{\\&quot;id\\&quot;:0}&quot;, JSON.toJSONString(new B())); } public static class A { public int id; } public static class B { public int id; } } fastjson支持多种方式定制序列化。 通过@JSONField定制序列化 通过@JSONType定制序列化 通过SerializeFilter定制序列化 通过ParseProcess定制反序列化 使用@JSONField配置可以把@JSONField配置在字段或者getter/setter方法上。例如： public class VO { @JSONField(name=&quot;ID&quot;) private int id; } 或 public class VO { private int id; @JSONField(name=&quot;ID&quot;) public int getId() { return id;} @JSONField(name=&quot;ID&quot;) public void setId(int value) {this.id = id;} } 使用format配置日期格式化 public class A { // 配置date序列化和反序列使用yyyyMMdd日期格式 @JSONField(format=&quot;yyyyMMdd&quot;) public Date date; } 使用serialize/deserialize指定字段不序列化 public class A { @JSONField(serialize=false) public Date date; } public class A { @JSONField(deserialize=false) public Date date; } 使用ordinal指定字段的顺序 缺省fastjson序列化一个java bean，是根据fieldName的字母序进行序列化的，你可以通过ordinal指定字段的顺序。这个特性需要1.1.42以上版本。 public static class VO { @JSONField(ordinal = 3) private int f0; @JSONField(ordinal = 2) private int f1; @JSONField(ordinal = 1) private int f2; } 使用serializeUsing制定属性的序列化类 在fastjson 1.2.16版本之后，JSONField支持新的定制化配置serializeUsing，可以单独对某一个类的某个属性定制序列化，比如： public static class Model { @JSONField(serializeUsing = ModelValueSerializer.class) public int value; } public static class ModelValueSerializer implements ObjectSerializer { @Override public void write(JSONSerializer serializer, Object object, Object fieldName, Type fieldType, int features) throws IOException { Integer value = (Integer) object; String text = value + &quot;元&quot;; serializer.write(text); } } 使用@JSONType配置和JSONField类似，但JSONType配置在类上，而不是field或者getter/setter方法上。 通过SerializeFilter定制序列化通过SerializeFilter可以使用扩展编程的方式实现定制序列化。fastjson提供了多种SerializeFilter： PropertyPreFilter 根据PropertyName判断是否序列化 PropertyFilter 根据PropertyName和PropertyValue来判断是否序列化 NameFilter 修改Key，如果需要修改Key,process返回值则可 ValueFilter 修改Value BeforeFilter 序列化时在最前添加内容 AfterFilter 序列化时在最后添加内容 以上的SerializeFilter在JSON.toJSONString中可以使用。 SerializeFilter filter = ...; // 可以是上面5个SerializeFilter的任意一种。 JSON.toJSONString(obj, filter); PropertyFilter 根据PropertyName和PropertyValue来判断是否序列化public interface PropertyFilter extends SerializeFilter { boolean apply(Object object, String propertyName, Object propertyValue); } 可以通过扩展实现根据object或者属性名称或者属性值进行判断是否需要序列化。例如： PropertyFilter filter = new PropertyFilter() { public boolean apply(Object source, String name, Object value) { if (&quot;id&quot;.equals(name)) { int id = ((Integer) value).intValue(); return id &gt;= 100; } return false; } }; JSON.toJSONString(obj, filter); // 序列化的时候传入filter PropertyPreFilter 根据PropertyName判断是否序列化和PropertyFilter不同只根据object和name进行判断，在调用getter之前，这样避免了getter调用可能存在的异常。 public interface PropertyPreFilter extends SerializeFilter { boolean apply(JSONSerializer serializer, Object object, String name); } NameFilter 序列化时修改Key如果需要修改Key,process返回值则可 public interface NameFilter extends SerializeFilter { String process(Object object, String propertyName, Object propertyValue); } fastjson内置一个PascalNameFilter，用于输出将首字符大写的Pascal风格。 例如： import com.alibaba.fastjson.serializer.PascalNameFilter; Object obj = ...; String jsonStr = JSON.toJSONString(obj, new PascalNameFilter()); ValueFilter 序列化是修改Valuepublic interface ValueFilter extends SerializeFilter { Object process(Object object, String propertyName, Object propertyValue); } BeforeFilter 序列化时在最前添加内容 在序列化对象的所有属性之前执行某些操作,例如调用 writeKeyValue 添加内容 public abstract class BeforeFilter implements SerializeFilter { protected final void writeKeyValue(String key, Object value) { ... } // 需要实现的抽象方法，在实现中调用writeKeyValue添加内容 public abstract void writeBefore(Object object); } AfterFilter 序列化时在最后添加内容 在序列化对象的所有属性之后执行某些操作,例如调用 writeKeyValue 添加内容 public abstract class AfterFilter implements SerializeFilter { protected final void writeKeyValue(String key, Object value) { ... } // 需要实现的抽象方法，在实现中调用writeKeyValue添加内容 public abstract void writeAfter(Object object); } 通过ParseProcess定制反序列化ParseProcess是编程扩展定制反序列化的接口。fastjson支持如下ParseProcess： ExtraProcessor 用于处理多余的字段 ExtraTypeProvider 用于处理多余字段时提供类型信息 使用ExtraProcessor 处理多余字段public static class VO { private int id; private Map&lt;String, Object&gt; attributes = new HashMap&lt;String, Object&gt;(); public int getId() { return id; } public void setId(int id) { this.id = id;} public Map&lt;String, Object&gt; getAttributes() { return attributes;} } ExtraProcessor processor = new ExtraProcessor() { public void processExtra(Object object, String key, Object value) { VO vo = (VO) object; vo.getAttributes().put(key, value); } }; VO vo = JSON.parseObject(&quot;{\\&quot;id\\&quot;:123,\\&quot;name\\&quot;:\\&quot;abc\\&quot;}&quot;, VO.class, processor); Assert.assertEquals(123, vo.getId()); Assert.assertEquals(&quot;abc&quot;, vo.getAttributes().get(&quot;name&quot;)); 使用ExtraTypeProvider 为多余的字段提供类型public static class VO { private int id; private Map&lt;String, Object&gt; attributes = new HashMap&lt;String, Object&gt;(); public int getId() { return id; } public void setId(int id) { this.id = id;} public Map&lt;String, Object&gt; getAttributes() { return attributes;} } class MyExtraProcessor implements ExtraProcessor, ExtraTypeProvider { public void processExtra(Object object, String key, Object value) { VO vo = (VO) object; vo.getAttributes().put(key, value); } public Type getExtraType(Object object, String key) { if (&quot;value&quot;.equals(key)) { return int.class; } return null; } }; ExtraProcessor processor = new MyExtraProcessor(); VO vo = JSON.parseObject(&quot;{\\&quot;id\\&quot;:123,\\&quot;value\\&quot;:\\&quot;123456\\&quot;}&quot;, VO.class, processor); Assert.assertEquals(123, vo.getId()); Assert.assertEquals(123456, vo.getAttributes().get(&quot;value&quot;)); // value本应该是字符串类型的，通过getExtraType的处理变成Integer类型了。 当对象存在引用时，序列化后的结果浏览器不支持，怎么办?使用SerializerFeature.DisableCircularReferenceDetect特性关闭引用检测和生成。例如： String jsonString = JSON.toJSONString(obj, SerializerFeature.DisableCircularReferenceDetect); fastjson 如何处理超大对象和超大JSON文本当需要处理超大JSON文本时，需要Stream API，在fastjson-1.1.32版本中开始提供Stream API。 序列化超大JSON数组序列化如果你的JSON格式是一个巨大的JSON数组，有很多元素，则先调用startArray，然后挨个写入对象，然后调用endArray。 JSONWriter writer = new JSONWriter(new FileWriter(&quot;/tmp/huge.json&quot;)); writer.startArray(); for (int i = 0; i &lt; 1000 * 1000; ++i) { writer.writeValue(new VO()); } writer.endArray(); writer.close(); 超大JSON对象序列化如果你的JSON格式是一个巨大的JSONObject，有很多Key/Value对，则先调用startObject，然后挨个写入Key和Value，然后调用endObject。 JSONWriter writer = new JSONWriter(new FileWriter(&quot;/tmp/huge.json&quot;)); writer.startObject(); for (int i = 0; i &lt; 1000 * 1000; ++i) { writer.writeKey(&quot;x&quot; + i); writer.writeValue(new VO()); } writer.endObject(); writer.close(); ##S 反序列化 JSONReader reader = new JSONReader(new FileReader(&quot;/tmp/huge.json&quot;)); reader.startArray(); while(reader.hasNext()) { VO vo = reader.readObject(VO.class); // handle vo ... } reader.endArray(); reader.close(); JSONReader reader = new JSONReader(new FileReader(&quot;/tmp/huge.json&quot;)); reader.startObject(); while(reader.hasNext()) { String key = reader.readString(); VO vo = reader.readObject(VO.class); // handle vo ... } reader.endObject(); reader.close(); 将对象中的空值输出输入输出空值 在fastjson中，缺省是不输出空值的。无论Map中的null和对象属性中的null，序列化的时候都会被忽略不输出，这样会减少产生文本的大小。但如果需要输出空值怎么做呢？ 使用SerializerFeature.WriteMapNullValueModel obj = ...; JSON.toJSONString(obj, SerializerFeature.WriteMapNullValue); 空值特别处理SerializerFeature 描述 WriteNullListAsEmpty 将Collection类型字段的字段空值输出为[] WriteNullStringAsEmpty 将字符串类型字段的空值输出为空字符串 “” WriteNullNumberAsZero 将数值类型字段的空值输出为0 WriteNullBooleanAsFalse将Boolean类型字段的空值输出为false class Model { public List&lt;Objec&gt; items; } Model obj = ....; String text = JSON.toJSONString(obj, SerializerFeature.WriteMapNullValue, SerializerFeature.WriteNullListAsEmpty); ContextValueFilter在某些场景下，对Value做过滤，需要获得所属JavaBean的信息，包括类型、字段、方法等。在fastjson-1.2.9中，提供了ContextValueFilter，类似于之前版本提供的ValueFilter，只是多了BeanContext参数可用。 package com.alibaba.fastjson.serializer; public interface ContextValueFilter extends SerializeFilter { Object process(BeanContext context, Object object, String name, Object value); } package com.alibaba.fastjson.serializer; public final class BeanContext { public Class&lt;?&gt; getBeanClass(); public Method getMethod(); public Field getField(); public String getName(); public String getLabel(); public &lt;T extends Annotation&gt; T getAnnation(Class&lt;T&gt; annotationClass); } Sample ContextValueFilter valueFilter = new ContextValueFilter() { public Object process(SerializeContext context, Object object, String name, Object value) { Class&lt;?&gt; objectClass = context.getBeanClass(); UrlIdentify annotation = context.getAnnation(UrlIdentify.class); // .... return value; } }; JSON.toJSONString(model, valueFilter);","categories":[{"name":"Java","slug":"Java","permalink":"https://skiyubon.github.io/categories/Java/"}],"tags":[{"name":"fastjson","slug":"fastjson","permalink":"https://skiyubon.github.io/tags/fastjson/"}]},{"title":"java动态代理和CGLIB","slug":"java动态代理和CGLIB","date":"2017-05-06T07:32:35.000Z","updated":"2017-06-26T03:51:44.656Z","comments":true,"path":"2017/05/06/java动态代理和CGLIB/","link":"","permalink":"https://skiyubon.github.io/2017/05/06/java动态代理和CGLIB/","excerpt":"","text":"静态代理模式因为需要对一些函数进行二次处理，或是某些函数不让外界知道时，可以使用代理模式，通过访问第三方，间接访问原函数的方式，达到以上目的，来看一下代理模式的类图：12345678910111213141516171819202122232425262728293031323334353637383940414243interface Hosee&#123; String sayhi();&#125; class Hoseeimpl implements Hosee&#123; @Override public String sayhi() &#123; return \"Welcome oschina hosee's blog\"; &#125; &#125; class HoseeProxy implements Hosee&#123; Hosee h; public HoseeProxy(Hosee h) &#123; this.h = h; &#125; @Override public String sayhi() &#123; System.out.println(\"I'm proxy!\"); return h.sayhi(); &#125; &#125; public class StaticProxy&#123; public static void main(String[] args) &#123; Hoseeimpl h = new Hoseeimpl(); HoseeProxy hp = new HoseeProxy(h); System.out.println(hp.sayhi()); &#125; &#125; 静态代理的弊端如果要想为多个类进行代理，则需要建立多个代理类，维护难度加大。 仔细想想，为什么静态代理会有这些问题，是因为代理在编译期就已经决定，如果代理哪个发生在运行期，这些问题解决起来就比较简单，所以动态代理的存在就很有必要了。 动态代理1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy; interface HoseeDynamic&#123; String sayhi();&#125; class HoseeDynamicimpl implements HoseeDynamic&#123; @Override public String sayhi() &#123; return \"Welcome oschina hosee's blog\"; &#125;&#125; class MyProxy implements InvocationHandler&#123; Object obj; public Object bind(Object obj) &#123; this.obj = obj; return Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"I'm proxy!\"); Object res = method.invoke(obj, args); return res; &#125;&#125; public class DynamicProxy&#123; public static void main(String[] args) &#123; MyProxy myproxy = new MyProxy(); HoseeDynamicimpl dynamicimpl = new HoseeDynamicimpl(); HoseeDynamic proxy = (HoseeDynamic)myproxy.bind(dynamicimpl); System.out.println(proxy.sayhi()); &#125;&#125; 类比静态代理，可以发现，代理类不需要实现原接口了，而是实现InvocationHandler。通过 12Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); 来动态生成一个代理类，该类的类加载器与被代理类相同，实现的接口与被代理类相同。 通过上述方法生成的代理类相当于静态代理中的代理类。 这样就实现了在运行期才决定代理对象是怎么样的，解决了静态代理的弊端。 当动态生成的代理类调用方法时，会触发invoke方法，在invoke方法中可以对被代理类的方法进行增强。 通过动态代理可以很明显的看到它的好处，在使用静态代理时，如果不同接口的某些类想使用代理模式来实现相同的功能，将要实现多个代理类，但在动态代理中，只需要一个代理类就好了。 除了省去了编写代理类的工作量，动态代理实现了可以在原始类和接口还未知的时候，就确定代理类的代理行为，当代理类与原始类脱离直接联系后，就可以很灵活地重用于不同的应用场景中。 动态代理的弊端代理类和委托类需要都实现同一个接口。也就是说只有实现了某个接口的类可以使用Java动态代理机制。但是，事实上使用中并不是遇到的所有类都会给你实现一个接口。因此，对于没有实现接口的类，就不能使用该机制。 而CGLIB则可以实现对类的动态代理 回调函数原理上文说了，当动态生成的代理类调用方法时，会触发invoke方法。 很显然invoke方法并不是显示调用的，它是一个回调函数，那么回调函数是怎么被调用的呢？ 上述动态代理的代码中，唯一不清晰的地方只有 12Proxy.newProxyInstance(obj.getClass().getClassLoader(), obj .getClass().getInterfaces(), this); 跟踪这个方法的源码，可以看到程序进行了验证、优化、缓存、同步、生成字节码、显示类加载等操作，前面的步骤并不是我们关注的重点，而最后它调用了 12byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces); 该方法用来完成生成字节码的动作，这个方法可以在运行时产生一个描述代理类的字节码byte[]数组。 在main函数中加入 1System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\",\"true\"); 加入这句代码后再次运行程序，磁盘中将会产生一个名为”$Proxy().class”的代理类Class文件，反编译（反编译工具我使用的是 JD-GUI ）后可以看见如下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException; public final class $Proxy0 extends Proxy implements HoseeDynamic&#123; private static Method m1; private static Method m3; private static Method m0; private static Method m2; public $Proxy0(InvocationHandler paramInvocationHandler) throws &#123; super(paramInvocationHandler); &#125; public final boolean equals(Object paramObject) throws &#123; try &#123; return ((Boolean)this.h.invoke(this, m1, new Object[] &#123; paramObject &#125;)).booleanValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String sayhi() throws &#123; try &#123; return (String)this.h.invoke(this, m3, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)this.h.invoke(this, m0, null)).intValue(); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)this.h.invoke(this, m2, null); &#125; catch (Error|RuntimeException localError) &#123; throw localError; &#125; catch (Throwable localThrowable) &#123; throw new UndeclaredThrowableException(localThrowable); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", new Class[] &#123; Class.forName(\"java.lang.Object\") &#125;); m3 = Class.forName(\"HoseeDynamic\").getMethod(\"sayhi\", new Class[0]); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\", new Class[0]); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\", new Class[0]); return; &#125; catch (NoSuchMethodException localNoSuchMethodException) &#123; throw new NoSuchMethodError(localNoSuchMethodException.getMessage()); &#125; catch (ClassNotFoundException localClassNotFoundException) &#123; throw new NoClassDefFoundError(localClassNotFoundException.getMessage()); &#125; &#125;&#125; 动态代理类不仅代理了显示定义的接口中的方法，而且还代理了java的根类Object中的继承而来的equals()、hashcode()、toString()这三个方法，并且仅此三个方法。 可以在上述代码中看到，无论调用哪个方法，都会调用到InvocationHandler的invoke方法，只是参数不同。 动态代理与静态代理的区别 Proxy类的代码被固定下来，不会因为业务的逐渐庞大而庞大； 可以实现AOP编程，这是静态代理无法实现的； 解耦，如果用在web业务下，可以实现数据层和业务层的分离。 动态代理的优势就是实现无侵入式的代码扩展。 静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题 CGLIBcglib是针对类来实现代理的，他的原理是对指定的目标类生成一个子类，并覆盖其中方法实现增强，但因为采用的是继承，所以不能对final修饰的类进行代理。CGLIB是通过生成java 字节码从而动态的产生代理对象，因此需要字节码解析处理的依赖asm类库，字节码动态生成的代理对象实际上是继承了委托类的。这种实现方式需要导入cglib和asm的类库。下面用到的例子是cglib-2.2.2.jar, asm-3.3.1.jar。cglib使用了MethodInterceptor，其中的方法是intercept(),这是拦截的概念，很容易就想到了Struts2的拦截器。 比较之下，Java API提供的动态代理需要面向接口，产生代理对象，因此委托类必须实现了接口才可以。而CGLIB不需要面向接口，可以代理简单类，但由于动态代理对象是继承委托类的，因此要求委托类不能是final的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.lang.reflect.Method; import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy; class CGlibHosee&#123; public String sayhi() &#123; return \"Welcome oschina hosee's blog\"; &#125;&#125; class CGlibHoseeProxy&#123; Object obj; public Object bind(final Object target) &#123; this.obj = target; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(obj.getClass()); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println(\"I'm proxy!\"); Object res = method.invoke(target, args); return res; &#125; &#125;); return enhancer.create(); &#125; &#125; public class CGlibProxy&#123; public static void main(String[] args) &#123; CGlibHosee cGlibHosee = new CGlibHosee(); CGlibHoseeProxy cGlibHoseeProxy = new CGlibHoseeProxy(); CGlibHosee proxy = (CGlibHosee) cGlibHoseeProxy.bind(cGlibHosee); System.out.println(proxy.sayhi()); &#125;&#125; cglib需要指定父类和回调方法。当然cglib也可以与Java动态代理一样面向接口，因为本质是继承。 Reference： http://blog.csdn.net/lidatgb/article/details/8941711 http://shensy.iteye.com/blog/1698197 http://www.cnblogs.com/jqyp/archive/2010/08/20/1805041.html http://www.shangxueba.com/jingyan/1853835.html 《深入理解Java虚拟机》 http://paddy-w.iteye.com/blog/841798","categories":[{"name":"Java","slug":"Java","permalink":"https://skiyubon.github.io/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"https://skiyubon.github.io/tags/Java基础/"}]},{"title":"Shiro","slug":"Shiro","date":"2017-04-25T07:40:03.000Z","updated":"2017-05-06T08:21:24.598Z","comments":true,"path":"2017/04/25/Shiro/","link":"","permalink":"https://skiyubon.github.io/2017/04/25/Shiro/","excerpt":"在尝试保护你的应用时，你是否有过挫败感？是否觉得现有的Java安全解决方案难以使用，只会让你更糊涂？本文介绍的Apache Shiro，是一个不同寻常的Java安全框架，为保护应用提供了简单而强大的方法。本文还解释了Apache Shiro的项目目标、架构理念以及如何使用Shiro为应用安全保驾护航。","text":"在尝试保护你的应用时，你是否有过挫败感？是否觉得现有的Java安全解决方案难以使用，只会让你更糊涂？本文介绍的Apache Shiro，是一个不同寻常的Java安全框架，为保护应用提供了简单而强大的方法。本文还解释了Apache Shiro的项目目标、架构理念以及如何使用Shiro为应用安全保驾护航。 什么是Apache Shiro？Apache Shiro（发音为“shee-roh”，日语“堡垒（Castle）”的意思）是一个强大易用的Java安全框架，提供了认证、授权、加密和会话管理功能，可为任何应用提供安全保障 - 从命令行应用、移动应用到大型网络及企业应用。 Shiro为解决下列问题（我喜欢称它们为应用安全的四要素）提供了保护应用的API： 认证 - 用户身份识别，常被称为用户“登录”；授权 - 访问控制；密码加密 - 保护或隐藏数据防止被偷窥；会话管理 - 每用户相关的时间敏感的状态。相关厂商内容 微信Android模块化架构重构实践 蘑菇街分布式消息中间件Corgi的架构演进 Serverless架构：一条SQL到一个服务有多远？ 对抗复杂性，架构设计中可借鉴复用这些手段 阿里：风控场景的模型平台架构设计相关赞助商 Shiro还支持一些辅助特性，如Web应用安全、单元测试和多线程，它们的存在强化了上面提到的四个要素。 为何要创建Apache Shiro？对于一个框架来讲，使其有存在价值的最好例证就是有让你去用它的原因，它应该能完成一些别人无法做到的事情。要理解这一点，需要了解Shiro的历史以及创建它时的其他替代方法。 在2008年加入Apache软件基金会之前，Shiro已经5岁了，之前它被称为JSecurity项目，始于2003年初。当时，对于Java应用开发人员而言，没有太多的通用安全替代方案 - 我们被Java认证/授权服务（或称为JAAS）紧紧套牢了。JAAS有太多的缺点 - 尽管它的认证功能尚可忍受，但授权方面却显得拙劣，用起来令人沮丧。此外，JAAS跟虚拟机层面的安全问题关系非常紧密，如判断JVM中是否允许装入一个类。作为应用开发者，我更关心应用最终用户能做什么，而不是我的代码在JVM中能做什么。 由于当时正从事应用开发，我也需要一个干净、容器无关的会话机制。在当时，“这场游戏”中唯一可用的会话是HttpSessions，它需要Web容器；或是EJB 2.1里的有状态会话Bean，这又要EJB容器。而我想要的一个与容器脱钩、可用于任何我选择的环境中的会话。 最后就是加密问题。有时，我们需要保证数据安全，但是Java密码架构（Java Cryptography Architecture）让人难以理解，除非你是密码学专家。API里到处都是Checked Exception，用起来很麻烦。我需要一个干净、开箱即用的解决方案，可以在需要时方便地对数据加密/解密。 于是，纵观2003年初的安全状况，你会很快意识到还没有一个大一统的框架满足所有上述需求。有鉴于此，JSecurity（即之后的Apache Shiro）诞生了。 今天，你为何愿意使用Apache Shiro？从2003年至今，框架选择方面的情况已经改变了不少，但今天仍有令人信服的理由让你选择Shiro。其实理由相当多，Apache Shiro： 易于使用 - 易用性是这个项目的最终目标。应用安全有可能会非常让人糊涂，令人沮丧，并被认为是“必要之恶”【译注：比喻应用安全方面的编程。】。若是能让它简化到新手都能很快上手，那它将不再是一种痛苦了。 广泛性 - 没有其他安全框架可以达到Apache Shiro宣称的广度，它可以为你的安全需求提供“一站式”服务。 灵活性 - Apache Shiro可以工作在任何应用环境中。虽然它工作在Web、EJB和IoC环境中，但它并不依赖这些环境。Shiro既不强加任何规范，也无需过多依赖。 Web能力 - Apache Shiro对Web应用的支持很神奇，允许你基于应用URL和Web协议（如REST）创建灵活的安全策略，同时还提供了一套控制页面输出的JSP标签库。 可插拔 - Shiro干净的API和设计模式使它可以方便地与许多的其他框架和应用进行集成。你将看到Shiro可以与诸如Spring、Grails、Wicket、Tapestry、Mule、Apache Camel、Vaadin这类第三方框架无缝集成。 支持 - Apache Shiro是Apache软件基金会成员，这是一个公认为了社区利益最大化而行动的组织。项目开发和用户组都有随时愿意提供帮助的友善成员。像Katasoft这类商业公司，还可以给你提供需要的专业支持和服务。 谁在用Shiro?Shiro及其前身JSecurity已被各种规模和不同行业的公司项目采用多年。自从成为Apache软件基金会的顶级项目后，站点流量和使用呈持续增长态势。许多开源社区也正在用Shiro，这里有些例子如Spring，Grails，Wicket，Tapestry，Tynamo，Mule和Vaadin。 如Katasoft，Sonatype，MuleSoft这样的商业公司，一家大型社交网络和多家纽约商业银行都在使用Shiro来保护他们的商业软件和站点。 核心概念：Subject，SecurityManager和Realms既然已经描述了Shiro的好处，那就让我们看看它的API，好让你能够有个感性认识。Shiro架构有三个主要概念 - Subject，SecurityManager和Realms。 Subject在考虑应用安全时，你最常问的问题可能是“当前用户是谁？”或“当前用户允许做X吗？”。当我们写代码或设计用户界面时，问自己这些问题很平常：应用通常都是基于用户故事构建的，并且你希望功能描述（和安全）是基于每个用户的。所以，对于我们而言，考虑应用安全的最自然方式就是基于当前用户。Shiro的API用它的Subject概念从根本上体现了这种思考方式。 Subject一词是一个安全术语，其基本意思是“当前的操作用户”。称之为“用户”并不准确，因为“用户”一词通常跟人相关。在安全领域，术语“Subject”可以是人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。在代码的任何地方，你都能轻易的获得Shiro Subject，参见如下代码： 清单1. 获得Subject1234import org.apache.shiro.subject.Subject;import org.apache.shiro.SecurityUtils;...Subject currentUser = SecurityUtils.getSubject(); 一旦获得Subject，你就可以立即获得你希望用Shiro为当前用户做的90%的事情，如登录、登出、访问会话、执行授权检查等 - 稍后还会看到更多。这里的关键点是Shiro的API非常直观，因为它反映了开发者以‘每个用户’思考安全控制的自然趋势。同时，在代码的任何地方都能很轻松地访问Subject，允许在任何需要的地方进行安全操作。 SecurityManagerSubject的“幕后”推手是SecurityManager。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。它是Shiro框架的核心，充当“保护伞”，引用了多个内部嵌套安全组件，它们形成了对象图。但是，一旦SecurityManager及其内部对象图配置好，它就会退居幕后，应用开发人员几乎把他们的所有时间都花在Subject API调用上。 那么，如何设置SecurityManager呢？嗯，这要看应用的环境。例如，Web应用通常会在Web.xml中指定一个Shiro Servlet Filter，这会创建SecurityManager实例，如果你运行的是一个独立应用，你需要用其他配置方式，但有很多配置选项。 一个应用几乎总是只有一个SecurityManager实例。它实际是应用的Singleton（尽管不必是一个静态Singleton）。跟Shiro里的几乎所有组件一样，SecurityManager的缺省实现是POJO，而且可用POJO兼容的任何配置机制进行配置 - 普通的Java代码、Spring XML、YAML、.properties和.ini文件等。基本来讲，能够实例化类和调用JavaBean兼容方法的任何配置形式都可使用。 为此，Shiro借助基于文本的INI配置提供了一个缺省的“公共”解决方案。INI易于阅读、使用简单并且需要极少依赖。你还能看到，只要简单地理解对象导航，INI可被有效地用于配置像SecurityManager那样简单的对象图。注意，Shiro还支持Spring XML配置及其他方式，但这里只我们只讨论INI。 下列清单2列出了基于INI的Shiro最简配置： 清单2. 用INI配置Shiro123456789101112[main]cm = org.apache.shiro.authc.credential.HashedCredentialsMatchercm.hashAlgorithm = SHA-512cm.hashIterations = 1024# Base64 encoding (less text):cm.storedCredentialsHexEncoded = falseiniRealm.credentialsMatcher = $cm[users] jdoe = TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJpcyByZWFzb2 asmith = IHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbXNoZWQsIG5vdCB 在清单2中，我们看到了用于配置SecurityManager实例的INI配置例子。有两个INI段落：[main]和[users]. [main]段落是配置SecurityManager对象及其使用的其他任何对象（如Realms）的地方。在示例中，我们看到配置了两个对象： cm对象，是Shiro的HashedCredentialsMatcher类实例。如你所见，cm实例的各属性是通过“嵌套点”语法进行配置的 - 在清单3中可以看到IniSecurityManagerFactory使用的惯例，这种方法代表了对象图导航和属性设置。iniRealm对象，它被SecurityManager用来表示以INI格式定义的用户帐户。[users]段落是指定用户帐户静态列表的地方 - 为简单应用或测试提供了方便。 就介绍而言，详细了解每个段落的细节并不是重点。相反，看到INI配置是一种配置Shiro的简单方式才是关键。关于INI配置的更多细节，请参见Shiro文档。 清单3. 装入shiro.ini配置文件123456import org.apache.shiro.SecurityUtils;import org.apache.shiro.config.IniSecurityManagerFactory;import org.apache.shiro.mgt.SecurityManager;import org.apache.shiro.util.Factory;... //1.装入INI配置Factory factory = new IniSecurityManagerFactory(“classpath:shiro.ini”); //2. 创建SecurityManagerSecurityManager securityManager = factory.getInstance(); //3. 使其可访问SecurityUtils.setSecurityManager(securityManager);在清单3的示例中，我们看到有三步： 装入用来配置SecurityManager及其构成组件的INI配置文件；根据配置创建SecurityManager实例（使用Shiro的工厂概念，它表述了工厂方法设计模式）；使应用可访问SecurityManager Singleton。在这个简单示例中，我们将它设置为VM静态Singleton，但这通常不是必须的 - 你的应用配置机制可以决定你是否需要使用静态存储。 RealmsShiro的第三个也是最后一个概念是Realm。Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当切实与像用户帐户这类安全相关数据进行交互，执行认证（登录）和授权（访问控制）时，Shiro会从应用配置的Realm中查找很多内容。 从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。 Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。下面的清单4是通过INI配置Shiro使用LDAP目录作为应用Realm的示例。 清单4. Realm配置示例片段：连接存储用户数据的LDAP12345[main]ldapRealm = org.apache.shiro.realm.ldap.JndiLdapRealmldapRealm.userDnTemplate = uid=&#123;0&#125;,ou=users,dc=mycompany,dc=comldapRealm.contextFactory.url = ldap://ldapHost:389ldapRealm.contextFactory.authenticationMechanism = DIGEST-MD5 既然已经了解如何建立一个基本的Shiro环境，下面让我们来讨论，作为一名开发者该如何使用这个框架。 认证认证是核实用户身份的过程。也就是说，当用户使用应用进行认证时，他们就在证明他们就是自己所说的那个人。有时这也理解为“登录”。它是一个典型的三步骤过程。 收集用户的身份信息，称为当事人（principal），以及身份的支持证明，称为证书（Credential）。将当事人和证书提交给系统。如果提交的证书与系统期望的该用户身份（当事人）匹配，该用户就被认为是经过认证的，反之则被认为未经认证的。这个过程的常见例子是大家都熟悉的“用户/密码”组合。多数用户在登录软件系统时，通常提供自己的用户名（当事人）和支持他们的密码（证书）。如果存储在系统中的密码（或密码表示）与用户提供的匹配，他们就被认为通过认证。 Shiro以简单直观的方式支持同样的流程。正如我们前面所说，Shiro有一个以Subject为中心的API - 几乎你想要用Shiro在运行时完成的所有事情都能通过与当前执行的Subject进行交互而达成。因此，要登录Subject，只需要简单地调用它的login方法，传入表示被提交当事人和证书（在这种情况下，就是用户名和密码）的AuthenticationToken实例。示例如清单5中所示： 清单5. Subject登录 //1. 接受提交的当事人和证书：AuthenticationToken token =new UsernamePasswordToken(username, password); //2. 获取当前Subject：Subject currentUser = SecurityUtils.getSubject();//3. 登录：currentUser.login(token);你可以看到，Shiro的API很容易地就反映了这个常见流程。你将会在所有的Subject操作中继续看到这种简单风格。在调用了login方法后，SecurityManager会收到AuthenticationToken，并将其发送给已配置的Realm，执行必须的认证检查。每个Realm都能在必要时对提交的AuthenticationTokens作出反应。但是如果登录失败了会发生什么？如果用户提供了错误密码又会发生什么？通过对Shiro的运行时AuthenticationException做出反应，你可以控制失败，参见清单6。 清单6. 控制失败的登录 //3. 登录：12345678910try &#123; currentUser.login(token);&#125; catch (IncorrectCredentialsException ice) &#123; …&#125; catch (LockedAccountException lae) &#123; …&#125;…catch (AuthenticationException ae) &#123;…&#125; 你可以选择捕获AuthenticationException的一个子类，作出特定的响应，或者对任何AuthenticationException做一般性处理（例如，显示给用户普通的“错误的用户名或密码”这类消息）。选择权在你，可以根据应用需要做出选择。 Subject登录成功后，他们就被认为是已认证的，通常你会允许他们使用你的应用。但是仅仅证明了一个用户的身份并不意味着他们可以对你的应用为所欲为。这就引出了另一个问题，“我如何控制用户能做或不能做哪些事情？”，决定用户允许做哪些事情的过程被称为授权。下面我们将谈谈Shiro如何进行授权。 授权授权实质上就是访问控制 - 控制用户能够访问应用中的哪些内容，比如资源、Web页面等等。多数用户执行访问控制是通过使用诸如角色和权限这类概念完成的。也就是说，通常用户允许或不允许做的事情是根据分配给他们的角色或权限决定的。那么，通过检查这些角色和权限，你的应用程序就可以控制哪些功能是可以暴露的。如你期望的，Subject API让你可以很容易的执行角色和权限检查。如清单7中的代码片段所示：如何检查Subject被分配了某个角色： 列表7. 角色检查12345if ( subject.hasRole(“administrator”) ) &#123; //显示‘Create User’按钮&#125; else &#123; //按钮置灰?&#125; 如你所见，你的应用程序可基于访问控制检查打开或关闭某些功能。 权限检查是执行授权的另一种方法。上例中的角色检查有个很大的缺陷：你无法在运行时增删角色。角色名字在这里是硬编码，所以，如果你修改了角色名字或配置，你的代码就会乱套！如果你需要在运行时改变角色含义，或想要增删角色，你必须另辟蹊径。 为此，Shiro支持了权限（permissions）概念。权限是功能的原始表述，如‘开门’，‘创建一个博文’，‘删除‘jsmith’用户’等。通过让权限反映应用的原始功能，在改变应用功能时，你只需要改变权限检查。进而，你可以在运行时按需将权限分配给角色或用户。 如清单8中，我们重写了之前的用户检查，取而代之使用权限检查。 清单8. 权限检查12345if ( subject.isPermitted(“user:create”) ) &#123; //显示‘Create User’按钮&#125; else &#123; //按钮置灰?&#125; 这样，任何具有“user:create”权限的角色或用户都可以点击‘Create User’按钮，并且这些角色和指派甚至可以在运行时改变，这给你提供了一个非常灵活的安全模型。 “user:create”字符串是一个权限字符串的例子，它遵循特定的解析惯例。Shiro借助它的WildcardPermission支持这种开箱即用的惯例。尽管这超出了本文的范围，你会看到在创建安全策略时，WildcardPermission非常灵活，甚至支持像实例级别访问控制这样的功能。 清单9. 实例级别的权限检查12345if ( subject.isPermitted(“user:delete:jsmith”) ) &#123; //删除‘jsmith’用户&#125; else &#123; //不删除‘jsmith’&#125; 该例表明，你可以对你需要的单个资源进行访问控制，甚至深入到非常细粒度的实例级别。如果愿意，你甚至还可以发明自己的权限语法。参见Shiro Permission文档可以了解更多内容。最后，就像使用认证那样，上述调用最终会转向SecurityManager，它会咨询Realm做出自己的访问控制决定。必要时，还允许单个Realm同时响应认证和授权操作。 以上就是对Shiro授权功能的简要概述。虽然多数安全框架止于授权和认证，但Shiro提供了更多功能。下面，我们将谈谈Shiro的高级会话管理功能。 会话管理在安全框架领域，Apache Shiro提供了一些独特的东西：可在任何应用或架构层一致地使用Session API。即，Shiro为任何应用提供了一个会话编程范式 - 从小型后台独立应用到大型集群Web应用。这意味着，那些希望使用会话的应用开发者，不必被迫使用Servlet或EJB容器了。或者，如果正在使用这些容器，开发者现在也可以选择使用在任何层统一一致的会话API，取代Servlet或EJB机制。 但Shiro会话最重要的一个好处或许就是它们是独立于容器的。这具有微妙但非常强大的影响。例如，让我们考虑一下会话集群。对集群会话来讲，支持容错和故障转移有多少种容器特定的方式？Tomcat的方式与Jetty的不同，而Jetty又和Websphere不一样，等等。但通过Shiro会话，你可以获得一个容器无关的集群解决方案。Shiro的架构允许可插拔的会话数据存储，如企业缓存、关系数据库、NoSQL系统等。这意味着，只要配置会话集群一次，它就会以相同的方式工作，跟部署环境无关 - Tomcat、Jetty、JEE服务器或者独立应用。不管如何部署应用，毋须重新配置应用。 Shiro会话的另一好处就是，如果需要，会话数据可以跨客户端技术进行共享。例如，Swing桌面客户端在需要时可以参与相同的Web应用会话中 - 如果最终用户同时使用这两种应用，这样的功能会很有用。那你如何在任何环境中访问Subject的会话呢？请看下面的示例，里面使用了Subject的两个方法。 清单10. Subject的会话 Session session = subject.getSession();Session session = subject.getSession(boolean create);如你所见，这些方法在概念上等同于HttpServletRequest API。第一个方法会返回Subject的现有会话，或者如果还没有会话，它会创建一个新的并将之返回。第二个方法接受一个布尔参数，这个参数用于判定会话不存在时是否创建新会话。一旦获得Shiro的会话，你几乎可以像使用HttpSession一样使用它。Shiro团队觉得对于Java开发者，HttpSession API用起来太舒服了，所以我们保留了它的很多感觉。当然，最大的不同在于，你可以在任何应用中使用Shiro会话，不仅限于Web应用。清单11中显示了这种相似性。 清单11. 会话的方法 Session session = subject.getSession(); session.getAttribute(&quot;key&quot;, someValue); Date start = session.getStartTimestamp(); Date timestamp = session.getLastAccessTime(); session.setTimeout(millis); ... 加密加密是隐藏或混淆数据以避免被偷窥的过程。在加密方面，Shiro的目标是简化并让JDK的加密支持可用。 清楚一点很重要，一般情况下，加密不是特定于Subject的，所以它是Shiro API的一部分，但并不特定于Subject。你可以在任何地方使用Shiro的加密支持，甚至在不使用Subject的情况下。对于加密支持，Shiro真正关注的两个领域是加密哈希（又名消息摘要）和加密密码。下面我们来看看这两个方面的详细描述。 哈希如果你曾使用过JDK的MessageDigest类，你会立刻意识到它的使用有点麻烦。MessageDigest类有一个笨拙的基于工厂的静态方法API，它不是面向对象的，并且你被迫去捕获那些永远都不必捕获的Checked Exceptions。如果需要输出十六进制编码或Base64编码的消息摘要，你只有靠自己 - 对上述两种编码，没有标准的JDK支持它们。Shiro用一种干净而直观的哈希API解决了上述问题。 打个比方，考虑比较常见的情况，使用MD5哈希一个文件，并确定该哈希的十六进制值。被称为‘校验和’，这在提供文件下载时常用到 - 用户可以对下载文件执行自己的MD5哈希。如果它们匹配，用户完全可以认定文件在传输过程中没有被篡改。 不使用Shiro，你需要如下步骤才能完成上述内容： 将文件转换成字节数组。JDK中没有干这事的，故而你需要创建一个辅助方法用于打开FileInputStream，使用字节缓存区，并抛出相关的IOExceptions，等等。使用MessageDigest类对字节数组进行哈希，处理相关异常，如清单12所示。将哈希后的字节数组编码成十六进制字符。JDK中还是没有干这事的，你依旧需要创建另外一个辅助方法，有可能在你的实现中会使用位操作和位移动。清单12. JDK的消息摘要1234567try &#123; MessageDigest md = MessageDigest.getInstance(\"MD5\"); md.digest(bytes); byte[] hashed = md.digest();&#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace();&#125; 对于这样简单普遍的需求，这个工作量实在太大了。现在看看Shiro是如何做同样事情的： String hex = new Md5Hash(myFile).toHex();当使用Shiro简化所有这些工作时，一切都非常简单明了。完成SHA-512哈希和密码的Base64编码也一样简单。 String encodedPassword = new Sha512Hash(password, salt, count).toBase64();你可以看到Shiro对哈希和编码简化了不少，挽救了你处理在这类问题上所消耗的脑细胞。 密码加密是使用密钥对数据进行可逆转换的加密算法。我们使用其保证数据的安全，尤其是传输或存储数据时，以及在数据容易被窥探的时候。 如果你曾经用过JDK的Cryptography API，特别是javax.crypto.Cipher类，你会知道它是一头需要驯服的极其复杂的野兽。对于初学者，每个可能的加密配置总是由一个javax.crypto.Cipher实例表示。必须进行公钥/私钥加密？你得用Cipher。需要为流操作使用块加密器（Block Cipher）？你得用Cipher。需要创建一个AES 256位Cipher来保护数据？你得用Cipher。你懂的。 那么如何创建你需要的Cipher实例？您得创建一个非直观、标记分隔的加密选项字符串，它被称为“转换字符串（transformation string）”，把该字符串传给Cipher.getInstance静态工厂方法。这种字符串方式的cipher选项，并没有类型安全以确保你正在用有效的选项。这也暗示没有JavaDoc帮你了解相关选项。并且，如果字符串格式组织不正确，你还需要进一步处理Checked Exception，即便你知道配置是正确的。如你所见，使用JDK Cipher是一项相当繁重的任务。很久以前，这些技术曾经是Java API的标准，但是世事变迁，我们需要一种更简单的方法。 Shiro通过引入它的CipherService API试图简化加密密码的整个概念。CipherService是多数开发者在保护数据时梦寐以求的东西：简单、无状态、线程安全的API，能够在一次方法调用中对整个数据进行加密或解密。你所需要做的只是提供你的密钥，就可根据需要加密或解密。如下列清单13中，使用256位AES加密： 清单13. Apache Shiro的加密API AesCipherService cipherService = new AesCipherService();cipherService.setKeySize(256); //创建一个测试密钥：byte[] testKey = cipherService.generateNewKey();//加密文件的字节：byte[] encrypted = cipherService.encrypt(fileBytes, testKey);较之JDK的Cipher API，Shiro的示例要简单的多： 你可以直接实例化一个CipherService - 没有奇怪或让人混乱的工厂方法；Cipher配置选项可以表示成JavaBean - 兼容的getter和setter方法 - 没有了奇怪和难以理解的“转换字符串”；加密和解密在单个方法调用中完成；没有强加的Checked Exception。如果愿意，可以捕获Shiro的CryptoException。Shiro的CipherService API还有其他好处，如同时支持基于字节数组的加密/解密（称为“块”操作）和基于流的加密/解密（如加密音频或视频）。 不必再忍受Java Cryptography带来的痛苦。Shiro的Cryptography支持就是为了减少你在确保数据安全上付出的努力。 Web支持最后，但并非不重要，我们将简单介绍一下Shiro的Web支持。Shiro附带了一个帮助保护Web应用的强建的Web支持模块。对于Web应用，安装Shiro很简单。唯一需要做的就是在web.xml中定义一个Shiro Servlet过滤器。清单14中，列出了代码。 清单14. web.xml中的ShiroFilter1234567891011&lt;filter&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;filter-class&gt; org.apache.shiro.web.servlet.IniShiroFilter &lt;/filter-class&gt; &lt;!-- 没有init-param属性就表示从classpath:shiro.ini装入INI配置 --&gt; &lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;ShiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 这个过滤器可以读取上述shiro.ini配置，这样不论什么开发环境，你都拥有了一致的配置体验。一旦完成配置，Shiro Filter就会过滤每个请求并且确保在请求期间特定请求的Subject是可访问的。同时由于它过滤了每个请求，你可以执行安全特定的逻辑以保证只有满足一定标准的请求才被允许通过。 URL特定的Filter链Shiro通过其创新的URL过滤器链功能支持安全特定的过滤规则。它允许你为任何匹配的URL模式指定非正式的过滤器链。这意味着， 使用Shiro的过滤器机制，你可以很灵活的强制安全规则（或者规则的组合） - 其程度远远超过你单独在web.xml中定义过滤器时所获得的。清单15中显示了Shiro INI中的配置片段。 清单15. 路径特定的Filter链123456[urls]/assets/** = anon/user/signup = anon/user/** = user/rpc/rest/** = perms[rpc:invoke], authc/** = authc 如你所见，Web应用可以使用[urls] INI段落。对于每一行，等号左边的值表示相对上下文的Web应用路径。等号右边的值定义了过滤器链 - 一个逗号分隔的有序Servlet过滤器列表，它会针对给出的路径进行执行。每个过滤器都是普通的Servlet过滤器，你看到的上面的过滤器名字（anon，user，perms，authc）是Shiro内置的安全相关的特殊过滤器。你可以搭配这些安全过滤器来创建高度定制的安全体验。你还可以指定任何其他现有的Servlet过滤器。 相比起使用web.xml，在其中先定义过滤器块，然后定义单独分离的过滤器模式块，这种方式带来的好处有多少？采用Shiro的方法，可以很容易就准确知道针对给定匹配路径执行的过滤器链。如果想这么做，你可以在web.xml中仅定义Shiro Filter，在shiro.ini中定义所有其他的过滤器和过滤器链，这要比web.xml简洁得多，而且更容易理解过滤器链定义机制。即使不使用Shiro的任何安全特性，单凭这样小小的方便之处，也值得让你使用Shiro。 JSP标签库Shiro还提供了JSP标签库，允许你根据当前Subject的状态控制JSP页面的输出。一个有用的常见示例是在用户登录后显示“Hello “文本。但若是匿名用户，你可能想要显示其他内容，如换而显示“Hello! Register Today!”。清单16显示了如何使用Shiro的JSP标签实现这个示例： 清单16. JSP 标签库示例12345678910111213&lt;%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %&gt;...&lt;p&gt;Hello&lt;shiro:user&gt; &lt;!-- shiro:principal打印出了Subject的主当事人 - 在这个示例中，就是用户名： --&gt; &lt;shiro:principal/&gt;!&lt;/shiro:user&gt;&lt;shiro:guest&gt; &lt;!-- 没有登录 - 就认为是Guest。显示注册链接： --&gt; ! &lt;a href=”register.jsp”&gt;Register today!&lt;/a&gt;&lt;/shiro:guest&gt;&lt;/p&gt; 除了上面例子用到的标签，还有其他标签可以让你根据用户属于（或不属于）的角色，分配（或未分配）的权限，是否已认证，是否来自“记住我”服务的记忆，或是匿名访客，包含输出。 Shiro还支持其他许多Web特性，如简单的“记住我”服务，REST和BASIC认证。当然，如果想使用Shiro原生的企业会话，它还提供透明的HttpSession支持。参见Apache Shiro Web文档可以了解更多内容。 #Web会话管理 最后值得一提的是Shiro在Web环境中对会话的支持。 缺省Http会话对于Web应用，Shiro缺省将使用我们习以为常的Servlet容器会话作为其会话基础设施。即，当你调用subject.getSession()和subject.getSession(boolean)方法时，Shiro会返回Servlet容器的HttpSession实例支持的Session实例。这种方式的曼妙之处在于调用subject.getSession()的业务层代码会跟一个Shiro Session实例交互 - 还没有“认识”到它正跟一个基于Web的HttpSession打交道。这在维护架构层之间的清晰隔离时，是一件非常好的事情。 Web层中Shiro的原生会话如果你由于需要Shiro的企业级会话特性（如容器无关的集群）而打开了Shiro的原生会话管理，你当然希望HttpServletRequest.getSession()和HttpSession API能和“原生”会话协作，而非Servlet容器会话。如果你不得不重构所有使用HttpServletRequest和HttpSession API的代码，使用Shiro的Session API来替换，这将非常令人沮丧。Shiro当然从来不会期望你这么做。相反，Shiro完整实现了Servlet规范中的Session部分以在Web应用中支持原生会话。这意味着，不管何时你使用相应的HttpServletRequest或HttpSession方法调用，Shiro都会将这些调用委托给内部的原生会话API。结果，你无需修改Web代码，即便是你正在使用Shiro的‘原生’企业会话管理 - 确实是一个非常方便（且必要）的特性。 附加特性Apache Shiro框架还包含有对保护Java应用非常有用的其他特性，如： 为维持跨线程的Suject提供了线程和并发支持（支持Executor和ExecutorService）；为了将执行逻辑作为一种特殊的Subject，支持Callable和Runnable接口；为了表现为另一个Subject的身份，支持“Run As”（比如，在管理应用中有用）；支持测试工具，这样可以很容易的对Shiro的安全代码进行单元测试和集成测试。框架局限常识告诉我们，Apache Shiro不是“银弹” - 它不能毫不费力的解决所有安全问题。如下是Shiro还未解决，但是值得知道的： 虚拟机级别的问题：Apache Shiro当前还未处理虚拟机级别的安全，比如基于访问控制策略，阻止类加载器中装入某个类。然而，Shiro集成现有的JVM安全操作并非白日做梦 - 只是没人给项目贡献这方面的工作。多阶段认证：目前，Shiro不支持“多阶段”认证，即用户可能通过一种机制登录，当被要求再次登录时，使用另一种机制登录。这在基于Shiro的应用中已经实现，但是通过应用预先收集所有必需信息再跟Shiro交互。这个功能在Shiro的未来版本中非常有可能得到支持。Realm写操作：目前所有Realm实现都支持“读”操作来获取验证和授权数据以执行登录和访问控制。诸如创建用户帐户、组和角色或与用户相关的角色组和权限这类“写”操作还不支持。这是因为支持这些操作的应用数据模型变化太大，很难为所有的Shiro用户强制定义“写”API。未来的特性Apache Shiro社区每天都在壮大，借此，Shiro的特性亦是如此。在即将发布的版本中，你可能会看到： 更干净的Web过滤机制，无需子类化就可支持更多的插件式过滤器。更多可插拔的缺省Realm实现，优先采用组合而非继承。你可以插入查找认证和授权数据的组件，无需实现为Shiro Realm的子类；强健的OpenID和OAuth（可能是混合）客户端支持；支持Captcha；针对纯无状态应用的配置简化（如，许多REST环境）；通过请求/响应协议进行多阶段认证；通过AuthorizationRequest进行粗粒度的授权；针对安全断言查询的ANTLR语法（比如，(‘role(admin) &amp;&amp; (guest || !group(developer))’）总结Apache Shiro是一个功能齐全、健壮、通用的Java安全框架，你可以用其为你的应用护航。通过简化应用安全的四个领域，即认证、授权、会话管理和加密，在真实应用中，应用安全能更容易被理解和实现。Shiro的简单架构和兼容JavaBean使其几乎能够在任何环境下配置和使用。附加的Web支持和辅助功能，比如多线程和测试支持，让这个框架为应用安全提供了“一站式”服务。Apache Shiro开发团队将继续前进，精炼代码库和支持社区。随着持续被开源和商业应用采纳，可以预期Shiro会继续发展壮大。 资源Apache Shiro的主页。Shiro的下载页面，包含面向Maven和Ant+Ivy用户的额外信息。Apache Shiro的文档页面，包含指南和参考手册。Apache Shiro演讲视频和幻灯，项目的PMC主席Les Hazlewood提供。其他关于Apache Shiro的文章和幻灯Apache Shiro的邮件列表和论坛。Katasoft - 提供Apache Shiro专业支持和应用安全产品的公司。","categories":[{"name":"Security","slug":"Security","permalink":"https://skiyubon.github.io/categories/Security/"}],"tags":[{"name":"Shiro","slug":"Shiro","permalink":"https://skiyubon.github.io/tags/Shiro/"}]},{"title":"Redis","slug":"Redis","date":"2017-04-23T06:46:12.000Z","updated":"2017-04-23T07:32:54.407Z","comments":true,"path":"2017/04/23/Redis/","link":"","permalink":"https://skiyubon.github.io/2017/04/23/Redis/","excerpt":"","text":"# 首页是系统的门户，也就是系统的入口。所以首页的访问量是这个系统最大的。如果每次展示首页都从数据库中查询首页的内容信息，那么势必会对数据库造成很大的压力，所以需要使用缓存来减轻数据库压力。实现缓存的工具有很多，现在比较流行的是redis。 Redis 的两种持久化方案rdb存储的是数据 aof存储的是操作","categories":[{"name":"Cache","slug":"Cache","permalink":"https://skiyubon.github.io/categories/Cache/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://skiyubon.github.io/tags/Redis/"}]},{"title":"架构漫谈（一）：什么是架构","slug":"架构漫谈（一）：什么是架构","date":"2017-04-17T06:11:31.000Z","updated":"2017-04-18T01:07:51.323Z","comments":true,"path":"2017/04/17/架构漫谈（一）：什么是架构/","link":"","permalink":"https://skiyubon.github.io/2017/04/17/架构漫谈（一）：什么是架构/","excerpt":"","text":"什么是架构架构的英文是Architecture，在Wikipedia上，架构是这样定义的： Architecture (Latin architectura, from the Greek ἀρχιτέκτων arkhitekton”architect”, from ἀρχι- “chief” and τέκτων “builder”) is both the process and the product of planning, designing, and constructing buildings and other physical structures。 建筑（拉丁建筑师，来自ἀρχι-“酋长”和“ἀκ”“建筑师”的希腊语ἀρχιτέκτωνarkhitekton“建筑师”）是规划，设计和建造建筑物和其他物理结构的过程和产物。 从这个定义上看，架构好像是一个过程，也不是很清晰。为了讲清楚这个问题，我们先来看看为什么会产生架构。 软件架构到底是要解决什么问题要解决谁的问题？如前所述，软件实际上就是把现实生活模拟到计算机中，并且软件是需要在计算机的硬件中运行起来的。要做到这一点需要解决两个问题： 业务问题具体的现实生活状态下，没有软件的时候，所解决的问题的主体是谁，解决的是什么问题，是如何解决，如何运作的？ 计算机问题 如何把现实生活用软件来模拟？ 模拟出来的软件，需要哪些硬件设施才能够满足要求？ 并且当访问量越来越大的时候，软件能否支持硬件慢慢长大，性能线性扩展？ 因为硬件是可能会失效的，软件如何在硬件失效的情况下，仍然能够保证可用性，让用户能够不中断的访问软件提供的服务？ 怎么收集软件产生的数据，为下一阶段的工作提供依据？ 分别是谁的问题呢？ 业务的owner需要提升业务的效率，降低业务的成本，这是动机。这个实际上就是业务的问题，所以一般软件开发的出发点就在这里。 是软件工程师的问题，要解决业务owner把业务虚拟化的问题，并且要解决软件开发和运营的生命周期的问题。 分别有什么问题？ 业务问题的本质，是业务所服务的对象的利益问题，明白了这个，就很容易搞清业务的概念和组织方式。再次强调一下，有了软件，可以降低业务的成本，没有软件的情况下，业务是一样跑的。如果只是为了跟风要用软件，说不定反而提高了成本，这个是采用软件之前首先要先搞清楚的。我们经常说软件和技术是业务的enabler，实际就是把原来成本很高的降到到了很低的程度而已，并不是有了什么新的业务。另外软件也不是降低业务成本的唯一方式。 为了能够让软件很好的跑起来，软件工程师必须理解业务所服务的对象，他们的利益所在，即业务问题。业务面对这些问题是如何分拆解决的？ 涉及到了哪些概念？ 这些概念分别解决了哪些哪些问题？ 我们不能自己按照自己的理解，用自己的一套概念体系来表述。如果这么做的话，会导致两个问题： 业务无法和我们交流，因为他们无法明白我们所自己创建的概念，所以他们无法确认我们的理解是否正确。 我们所表述的东西，并没有在实际生活中实践过，我们也不知道这些概念是否能够解决业务的问题。 软件工程师还必须要考虑，用什么样的硬件把软件跑起来，怎样跑得好，跑得快，并且可以随着业务的流量逐渐的长大？ 分析问题对于2，在有限的时间下，软件工程师毫无疑问无法一个人去完成这么多事情，那么我们需要把所做的事情列出来，进行分析。 虚拟化业务需要完成这些事情： 学习业务知识，认识业务所涉及的stakeholders的核心利益述求，以及业务是如何分拆满足这些利益述求，并通过怎样的组织架构完成整个组织的核心利益的，以及业务运作的流程，涉及到哪些概念，有哪些权利和责任等。 通过对业务知识的学习，针对这些概念所对应的权利和责任以及组织架构，对业务进行建模，把并把建模的结果用编程语言实现。这是业务的模型，通常是现实生活中利益斗争的结果，是非常稳定的。 学习业务所参与的stakeholder是如何和业务打交道，并完成每个人的权利和义务的，并通过编程语言，结合业务模型实现这些打交道的沟通通道。这部分是变化最频繁的，属于组合关系。明白了这一点，对后续的实现非常有帮助。 如何把业务运行的结果，持久化，并通过合适的手段把持久化后的数据，在合适的时间合适的地点加载出来。这部分和基础设施有关，变化可能也会比较频繁。 代码如何运营，需要完成这些事情： 需要多少硬件设备来满足访问的需求？ 代码要分成多少个组件部署到哪些硬件设备上？ 这些代码如何通过硬件设备互相连接在一起？ 当业务流量增大到超过一台机器的容量时，软件能否支持通过部署到新增机器上的方式，扩大对业务的支撑？ 当某台或某些硬件设备失效时，软件是否仍然能够不影响用户的访问。 软件运行产生的数据，能否支持提取出来并加以分析，为下一轮的业务决策提供依据。 如果分成不同的角色来完成这些事情，就需要一个组织架构来组织代码的编写和运营，需要做哪些事情： 完成一和二所列的这些事情，需要哪些角色参与？ 这些事情基本都需要顺序的发生，如何保证信息在不同角色的传递过程中不会有损失？ 或者说即使有损失，也能快速纠正？ 这些角色之间是如何协调，才能共同完成虚拟化业务的需求？ 会产生哪些架构如果业务足够简单，用户流量够小，时间要求也不急迫，那么一个人，一台机器就够了，这个时候一般不会去讨论架构的问题。当访问的流量越来越大，机器就会越来越多，代码的部署单元就会拆分的越来越多。 同样就会需要越来越多的人来完成拆分出来的越来越多的部署单元，甚至同一个部署单元也需要分拆为多人合作完成。但是我们需要注意到一点，整个的概念体系，或者说业务的建模不会有任何的变化，还是完成同样的这些事情。唯一的区别就是量越来越大，超过了单个人和单个机器的容量，不断地增长。这样就会导致以下的架构： 当流量越来越大，我们就会发现，软件所部属的机器就会开始按照树状的结构开始分拆，就会形成硬件的部属架构。这就是为什么会形成部署的分层。 为了把业务在软件中实现并落地，需要前端人员、业务代码人员、存储层等不同技巧的人同时工作，需要切分成代码的架构。这就是为什么会形成代码的分层，形成代码的架构。当然，当这些角色由一个人来完成的时候，不一定会有代码架构，往往会比较乱。 当参与的人员越来越多，就会形成开发体系的组织架构。因为代码开发的过程是一个连续的过程，会用流程来吧不同的角色串联起来，这就是软件工程。 为了完成业务的工作，需要识别出来业务架构和支撑业务的组织架构，以及业务运作的流程。这是被虚拟化的业务架构和组织架构，也需要体现在代码中，保持和现实生活中一致。 什么是软件架构这就是软件比较复杂的地方，涉及到软件本身的业务体系，和所虚拟的业务体系。根据以上的分析，所生成的架构，究竟那些算是软件架构呢？ 软件因为流量增大而分拆成不同的运行单元，在不同的机器上部署所形成的架构，属于软件架构。 每个运行单元为了让不同角色的人，比如前端，业务，数据存储等能够并行工作，所分成的代码架构，也属于软件架构。 所以当我们说软件架构的时候，我们一定要讲清楚，究竟说的是部署的架构，还是代码的架构。软件架构的落地，需要软件的组织架构和流程来保障，离开了这个，软件架构是一句空话。 另外很多人讲，架构是进化出来的。架构实际上是在量不断的增大，超过了单台服务器的容量，逐渐的分拆，同时导致超过单个人员的能力，工作人员不断的增多，工作内容不断的分拆形成的。这本身就是架构的意义所在。不管怎么分拆，所达到的目标没有任何变化，就是完成业务在计算机中的虚拟化。","categories":[{"name":"软件架构","slug":"软件架构","permalink":"https://skiyubon.github.io/categories/软件架构/"}],"tags":[{"name":"软件架构","slug":"软件架构","permalink":"https://skiyubon.github.io/tags/软件架构/"}]},{"title":"MyBatis","slug":"MyBatis","date":"2017-04-13T02:27:08.000Z","updated":"2017-04-15T08:27:21.497Z","comments":true,"path":"2017/04/13/MyBatis/","link":"","permalink":"https://skiyubon.github.io/2017/04/13/MyBatis/","excerpt":"MyBatis 是一个简化和实现了 Java 数据持久化层(persistence layer)的开源框架，它抽象了大量的 JDBC 冗余代码，并提供了一个简单易用的 API 和数据库交互。MyBatis 的前身是 iBATIS，iBATIS 于 2002 年由 Clinton Begin 创建。 MyBatis 3 是 iBATIS 的全新设计，支持注解和 Mapper。MyBatis 流行的主要原因在于它的简单性和易使用性。在 Java 应用程序中，数据持久化层涉及到的工作有：将从数据库查询到的数据生成所需要的 Java 对象；将 Java 对象中的数据通过 SQL 持久化到数据库中。MyBatis 通过抽象底层的 JDBC 代码，自动化 SQL 结果集产生 Java 对象、 Java 对象的数据持久化数据库中的过程使得对 SQL 的使用变得容易。如 果 你 正 在 使 用 iBATIS ， 并 且 想 将 iBATIS 移 植 到 MyBatis 上 ， 你 可 以 在 MyBatis 的 官 方 网 站（ https://code.google.com/p/mybatis/wiki/DocUpgrade ）上找到详细的指导步骤。","text":"MyBatis 是一个简化和实现了 Java 数据持久化层(persistence layer)的开源框架，它抽象了大量的 JDBC 冗余代码，并提供了一个简单易用的 API 和数据库交互。MyBatis 的前身是 iBATIS，iBATIS 于 2002 年由 Clinton Begin 创建。 MyBatis 3 是 iBATIS 的全新设计，支持注解和 Mapper。MyBatis 流行的主要原因在于它的简单性和易使用性。在 Java 应用程序中，数据持久化层涉及到的工作有：将从数据库查询到的数据生成所需要的 Java 对象；将 Java 对象中的数据通过 SQL 持久化到数据库中。MyBatis 通过抽象底层的 JDBC 代码，自动化 SQL 结果集产生 Java 对象、 Java 对象的数据持久化数据库中的过程使得对 SQL 的使用变得容易。如 果 你 正 在 使 用 iBATIS ， 并 且 想 将 iBATIS 移 植 到 MyBatis 上 ， 你 可 以 在 MyBatis 的 官 方 网 站（ https://code.google.com/p/mybatis/wiki/DocUpgrade ）上找到详细的指导步骤。 为什么选择 MyBatis？当前有很多 Java 实现的持久化框架，而 MyBatis 流行起来有以下原因： 它消除了大量的 JDBC 冗余代码 它有低的学习曲线 它能很好地与传统数据库协同工作 它可以接受 SQL 语句 它提供了与 Spring 和 Guice 框架的集成支持 它提供了与第三方缓存类库的集成支持 它引入了更好的性能 消除大量的 JDBC 冗余代码你不需要创建 Connection 连接，PreparedStatement，不需要自己对每一次数据库操作进行手动设置参数和关闭连接。只需要配置数据库连接属性和 SQL 语句，MyBatis 会处理这些底层工作。 另外，MyBatis 还提供了其他的一些特性来简化持久化逻辑的实现: 它支持复杂的 SQL 结果集数据映射到嵌套对象图结构 它支持一对一和一对多的结果集和 Java 对象的映射 它支持根据输入的数据构建动态的 SQL 语句 能够很好地与传统数据库协同工作有时我们可能需要用不正规形式与传统数据库协同工作，使用成熟的 ORM 框架（如 Hibernate）有可能、 但是很难跟传统数据库很好地协同工作，因为他们尝试将 Java 对象静态地映射到数据库的表上。而 MyBatis 是将查询的结果与 Java 对象映射起来，这使得 MyBatis 可以很好地与传统数据库协同工作。你可以根据面相对象的模型创建 Java 域对象，执行传统数据库的查询，然后将结果映射到对应的 Java 对象上。 接受 SQL成熟的 ORM 框架（如 Hibernate）鼓励使用实体对象（Entity Objects）和在其底层自动产生 SQL 语句。由于这种的 SQL 生成方式，我们有可能不能够利用到数据库的一些特有的特性。 Hibernate 允许执行本地SQL，但是这样会打破持久层和数据库独立的原则。MyBatis 框架接受 SQL 语句，而不是将其对开发人员隐藏起来。由于 MyBatis 不会产生任何的 SQL 语句，所以开发人员就要准备 SQL 语句，这样就可以充分利用数据库特有的特性并且可以准备自定义的查询。另外，MyBatis 对存储过程也提供了支持。 与 Spring 和 Guice 框架的集成支持MyBatis 提供了与 流行的依赖注入框架 Spring 和 Guice 的开包即用的集成支持，这将进一步简化 MyBatis 的使用 与第三方缓存类库的集成支持MyBatis 有内建的 SqlSession 级别的缓存机制，用于缓存 Select 语句查询出来的结果。除此之外，MyBatis 提供了与多种第三方缓存类库的集成支持，如 EHCache，OSCache，Hazelcast。 良好的性能性能问题是关乎软件应用成功与否的关键因素之一。为了达到更好的性能，需要考虑很多事情，而对很多应用而言，数据持久化层是整个系统性能的关键。MyBatis 支持数据库连接池，消除了为每一个请求创建一个数据库连接的开销MyBatis 提供了内建的缓存机制，在 SqlSession 级别提供了对 SQL 查询结果的缓存。即:如果你调用了相同的select 查询，MyBatis 会将放在缓存的结果返回，而不会去再查询数据库。MyBatis 框架并没有大量地使用代理机制2，因此对于其他的过度地使用代理的 ORM 框架而言，MyBatis 可以获得更好的性能。 在软件开发中，并没有通用的（一体适用）的解决方案，每一个应用会有不同的一系列的要求，而我们应该根据应用的需要来选择我们的工具和框架。在前一节中，我们看到了使用 MyBatis 的优点。然而也有一些情况，MyBatis 并不是理想的或者是最好的解决方案。如果你的应用是以面向对象模型，并且向动态生成 SQL 语句，那么 MyBatis可能就不符合你的要求。另外，如果你想让你的应用有一个传递性的缓存机制的话（保存父对象时也应该保存关联的子对象），Hibernate 会更适合你。 MyBatis入门（安装和配置简单示例） 新建一个 Java 项目，将 MyBatis-3.2.2.jar 添加到 classpath 中 新建 mybatis-config.xml 和映射器 StudentMapper.xml 配置文件 新建 MyBatisSqlSessionFactory 单例类 1234567891011121314151617181920public class MyBatisSqlSessionFactory &#123; private static SqlSessionFactory sqlSessionFactory; public static SqlSessionFactory getSqlSessionFactory() &#123; if (sqlSessionFactory == null) &#123; InputStream inputStream; try &#123; inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\"); //加载核心配置文件 sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //生成SqlSessionFactory &#125; catch (IOException e) &#123; throw new RuntimeException(e.getCause()); &#125; &#125; return sqlSessionFactory; &#125; public static SqlSession openSession() &#123; //从sqlSessionFactory中获取SqlSession return getSqlSessionFactory().openSession(); &#125;&#125; 新建 StudentMapper 接口和 StudentService 类 新建一个 JUnit 测试类来测试 StudentService 它是怎么工作的首先，我们配置了 MyBatis 最主要的配置文件-mybatis-config.xml,里面包含了 JDBC 连接参数；配置了映射器Mapper XML 配置文件文件，里面包含了 SQL 语句的映射。我们使用 mybatis-config.xml 内的信息创建了 SqlSessionFactory 对象。每个数据库环境应该就一个SqlSessionFactory 对象实例，所以我们使用了单例模式只创建一个 SqlSessionFactory 实例。我们创建了一个映射器 Mapper 接口-StudentMapper，其定义的方法签名和在 StudentMapper.xml 中定义的完全一样（即映射器 Mapper 接口中的方法名跟 StudentMapper.xml 中的 id 的值相同）。注意StudentMapper.xml 中namespace 的值被设置成com.mybatis3.mappers.StudentMapper，是StudentMapper 接口的完全限定名。这使我们可以使用接口来调用映射的 SQL 语句。在 StudentService.java 中，我们在每一个方法中创建了一个新的 SqlSession，并在方法功能完成后关闭SqlSession。每一个线程应该有它自己的 SqlSession 实例。 SqlSession 对象实例不是线程安全的，并且不被共享。所以 SqlSession 的作用域最好就是其所在方法的作用域。从 Web 应用程序角度上看，SqlSession 应该存在于 request 级别作用域上。 MyBatis的配置元素和SqlSessionFactoryMyBatis 最关键的组成部分是 SqlSessionFactory，我们可以从中获取 SqlSession，并执行映射的 SQL 语句。SqlSessionFactory 对象可以通过基于 XML 的配置信息或者 Java API 创建。我们将探索各种 MaBatis 配置元素，如 dataSource，environments,全局参数设置,typeAlias，typeHandlers，SQL 映射；接着我们将实例化 SqlSessionFactory。 使用XML配置MyBatis构建 SqlSessionFactory 最常见的方式是基于 XML 配置（的构造方式）。下面的 mybatis-config.xml 展示了一个典型的 MyBatis 配置文件的样子：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"application.properties\"&gt; &lt;property name=\"username\" value=\"db_user\" /&gt; &lt;property name=\"password\" value=\"verysecurepwd\" /&gt; &lt;/properties&gt; &lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\" /&gt; &lt;/settings&gt; &lt;typeAliases&gt; &lt;typeAlias alias=\"Tutor\" type=\"com.mybatis3.domain.Tutor\" /&gt; &lt;package name=\"com.mybatis3.domain\" /&gt; &lt;/typeAliases&gt; &lt;typeHandlers&gt; &lt;typeHandler handler=\"com.mybatis3.typehandlers. PhoneTypeHandler\" /&gt; &lt;package name=\"com.mybatis3.typehandlers\" /&gt; &lt;/typeHandlers&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driverClassName&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"production\"&gt; &lt;transactionManager type=\"MANAGED\" /&gt; &lt;dataSource type=\"JNDI\"&gt; &lt;property name=\"data_source\" value=\"java:comp/jdbc/MyBatisDemoDS\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"com/mybatis3/mappers/StudentMapper.xml\" /&gt; &lt;mapper url=\"file:///D:/mybatisdemo/mappers/TutorMapper.xml\" /&gt; &lt;mapper class=\"com.mybatis3.mappers.TutorMapper\" /&gt; &lt;/mappers&gt;&lt;/configuration&gt; environmentMyBatis 支持配置多个 dataSource 环境，可以将应用部署到不同的环境上，如 DEV(开发环境)，TEST（测试换将），QA（质量评估环境）,UAT(用户验收环境),PRODUCTION（生产环境），可以通过将默认 environment 值设置成想要的environment id 值。在上述的配置中，默认的环境 environment 被设置成 development。当需要将程序部署到生产服务器上时，你不需要修改什么配置，只需要将默认环境 environment 值设置成生产环境的 environment id 属性即可。有时候，我们可能需要在相同的应用下使用多个数据库。比如我们可能有 SHOPPING-CART 数据库来存储所有的订单明细；使用 REPORTS 数据库存储订单明细的合计，用作报告。如果你的应用需要连接多个数据库，你需要将每个数据库配置成独立的环境，并且为每一个数据库创建一个SqlSessionFactory。 1234567891011121314&lt;environments default=\"shoppingcart\"&gt; &lt;environment id=\"shoppingcart\"&gt; &lt;transactionManager type=\"MANAGED\" /&gt; &lt;dataSource type=\"JNDI\"&gt; &lt;property name=\"data_source\" value=\"java:comp/jdbc/ ShoppingcartDS\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=\"reports\"&gt; &lt;transactionManager type=\"MANAGED\" /&gt; &lt;dataSource type=\"JNDI\"&gt; &lt;property name=\"data_source\" value=\"java:comp/jdbc/ReportsDS\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 我们可以如下为每个环境创建一个 SqlSessionFactory:1234inputStream = Resources.getResourceAsStream(\"mybatis-config.xml\");defaultSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);cartSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, \"shoppingcart\");reportSqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream, \"reports\"); 创建 SqlSessionFactory 时，如果没有明确指定环境 environment id，则会使用默认的环境 environment 来创建。在上述的源码中，默认的 SqlSessionFactory 便是使用 shoppingcart 环境设置创建的。对于每个环境 environment,我们需要配置 dataSource 和 transactionManager 元素。 数据源 DataSourcedataSource 元素被用来配置数据库连接属性。123456&lt;dataSource type=\"POOLED\"&gt;&lt;property name=\"driver\" value=\"$&#123;jdbc.driverClassName&#125;\" /&gt;&lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt;&lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt;&lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/dataSource&gt; dataSource 的类型可以配置成其内置类型之一，如 UNPOOLED，POOLED，JNDI。 如果将类型设置成 UNPOOLED，MyBatis 会为每一个数据库操作创建一个新的连接，并关闭它。该方式适用于只有小规模数量并发用户的简单应用程序上。 如果将属性设置成 POOLED，MyBatis 会创建一个数据库连接池，连接池中的一个连接将会被用作数据库操作。一旦数据库操作完成，MyBatis 会将此连接返回给连接池。在开发或测试环境中，经常使用此种方式。 如果将类型设置成 JNDI，MyBatis 从在应用服务器向配置好的 JNDI 数据源 dataSource 获取数据库连接。在生产环境中，优先考虑这种方式。 事务管理器 TransactionManagerMyBatis 支持两种类型的事务管理器： JDBC and MANAGED. JDBC 事务管理器被用作当应用程序负责管理数据库连接的生命周期（提交、回退等等）的时候。当你将TransactionManager 属性设置成 JDBC，MyBatis 内部将使用 JdbcTransactionFactory 类创建TransactionManager。例如，部署到 Apache Tomcat 的应用程序，需要应用程序自己管理事务。 MANAGED 事务管理器是当由应用服务器负责管理数据库连接生命周期的时候使用。当你将TransactionManager 属性设置成 MANAGED 时， MyBatis 内部使用 ManagedTransactionFactory 类创建事务管理器TransactionManager。例如，当一个 JavaEE的应用程序部署在类似 JBoss， WebLogic，GlassFish 应用服务器上时，它们会使用 EJB 进行应用服务器的事务管理能力。在这些管理环境中，你可以使用 MANAGED 事务管理器。（译者注：Managed 是托管的意思，即是应用本身不去管理事务，而是把事务管理交给应用所在的服务器进行管理。） 属性 Properties属性配置元素可以将配置值具体化到一个属性文件中，，并且使用属性文件的 key 名作为占位符。在上述的配置中，我们将数据库连接属性具体化到了 application.properties 文件中，并且为 driver，URL 等属性使用了占位符。 在 applications.properties 文件中配置数据库连接参数，如下所示： jdbc.driverClassName=com.mysql.jdbc.Driver jdbc.url=jdbc:mysql://localhost:3306/mybatisdemo jdbc.username=root jdbc.password=admin 在 mybatis-config.xml 文件中，为属性使用 application.properties 文件中定义的占位符： 12345678910&lt;properties resource=\"application.properties\"&gt; &lt;property name=\"jdbc.username\" value=\"db_user\" /&gt; &lt;property name=\"jdbc.password\" value=\"verysecurepwd\" /&gt;&lt;/properties&gt;&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driverClassName&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/dataSource&gt; 并且，你可以在元素中配置默认参数的值。如果中定义的元素和属性文件定义元素的 key值相同，它们会被属性文件中定义的值覆盖。 1234&lt;properties resource=\"application.properties\"&gt; &lt;property name=\"jdbc.username\" value=\"db_user\" /&gt; &lt;property name=\"jdbc.password\" value=\"verysecurepwd\" /&gt;&lt;/properties&gt; 这里，如果 application.properties 文件包含值 jdbc.username 和 jdbc.password，则上述定义的 username 和password 的值 db_user 和 verysecurepwd 将会被 application.properties 中定义的对应的 jdbc.username 和jdbc.password 值覆盖。 类型别名 typeAliases在 SQLMapper 配置文件中，对于 resultType 和 parameterType 属性值，我们需要使用 JavaBean 的完全限定名。如下例子所示：12345678910&lt;select id=\"findStudentById\" parameterType=\"int\" resultType=\"com.mybatis3.domain.Student\"&gt; SELECT STUD_ID AS ID, NAME, EMAIL, DOB FROM STUDENTS WHERE STUD_ID=#&#123;Id&#125;&lt;/select&gt;&lt;update id=\"updateStudent\" parameterType=\"com.mybatis3.domain. Student\"&gt; UPDATE STUDENTS SET NAME=#&#123;name&#125;, EMAIL=#&#123;email&#125;, DOB=#&#123;dob&#125; WHERE STUD_ID=#&#123;id&#125;&lt;/update&gt; 这里我们为 resultType 和 parameterType 属性值设置为 Student 类型的完全限定名：com.mybatis3.domain.Student我们可以为完全限定名取一个别名（alias），然后其需要使用完全限定名的地方使用别名，而不是到处使用完全限定名。如下例子所示，为完全限定名起一个别名：12345&lt;typeAliases&gt; &lt;typeAlias alias=\"Student\" type=\"com.mybatis3.domain.Student\" /&gt; &lt;typeAlias alias=\"Tutor\" type=\"com.mybatis3.domain.Tutor\" /&gt; &lt;package name=\"com.mybatis3.domain\" /&gt;&lt;/typeAliases&gt; 然后在 SQL Mapper 映射文件中, 如下使用 Student 的别名：123456789&lt;select id=\"findStudentById\" parameterType=\"int\" resultType=\"Student\"&gt; SELECT STUD_ID AS ID, NAME, EMAIL, DOB FROM STUDENTS WHERE STUD_ID=#&#123;id&#125;&lt;/select&gt;&lt;update id=\"updateStudent\" parameterType=\"Student\"&gt; UPDATE STUDENTS SET NAME=#&#123;name&#125;, EMAIL=#&#123;email&#125;, DOB=#&#123;dob&#125; WHERE STUD_ID=#&#123;id&#125;&lt;/update&gt; 你可以不用为每一个 JavaBean 单独定义别名, 你可以为提供需要取别名的 JavaBean 所在的包(package)，MyBatis会自动扫描包内定义的 JavaBeans，然后分别为 JavaBean 注册一个小写字母开头的非完全限定的类名形式的别名。如下所示，提供一个需要为 JavaBeans 起别名的包名：123&lt;typeAliases&gt; &lt;package name=\"com.mybatis3.domain\" /&gt;&lt;/typeAliases&gt; 如果 Student.java 和 Tutor.java Bean 定义在 com.mybatis3.domain 包中，则com.mybatis3.domain.Student的别名会被注册为 student。而 com.mybatis3.domain.Tutor 别名将会被注册为 tutor。示例如下：123456&lt;typeAliases&gt; &lt;typeAlias alias=\"Student\" type=\"com.mybatis3.domain.Student\" /&gt; &lt;typeAlias alias=\"Tutor\" type=\"com.mybatis3.domain.Tutor\" /&gt; &lt;package name=\"com.mybatis3.domain\" /&gt; &lt;package name=\"com.mybatis3.webservices.domain\" /&gt;&lt;/typeAliases&gt; 还有另外一种方式为 JavaBeans 起别名，使用注解@Alias:1234@Alias(\"StudentAlias\")public class Student&#123; &#125; 类型处理器 typeHandlers如上一章已经讨论过，MyBatis 通过抽象 JDBC 来简化了数据持久化逻辑的实现。 MyBatis 在其内部使用 JDBC，提供了更简洁的方式实现了数据库操作。当 MyBatis 将一个 Java 对象作为输入参数执行 INSERT 语句操作时，它会创建一个 PreparedStatement 对象，并且使用 setXXX()方式对占位符设置相应的参数值。这里，XXX 可以是 Int，String，Date 等 Java 对象属性类型的任意一个。示例如下：1234&lt;insert id=\"insertStudent\" parameterType=\"Student\"&gt; INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(#&#123;studId&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;dob&#125;)&lt;/insert&gt; 为执行这个语句，MyBatis 将采取以下一系列动作： 创建一个有占位符的 PreparedStatement 接口，如下： 12PreparedStatement pstmt = connection .prepareStatement(\"INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,DOB) VALUES(?,?,?,?)\"); 检查 Student 对象的属性 studId 的类型，然后使用合适 setXXX 方法去设置参数值。这里 studId 是 integer类型，所以会使用 setInt()方法： 1pstmt.setInt(1,student.getStudId()); 类似地，对于 name 和 email 属性都是 String 类型，MyBatis 使用 setString()方法设置参数。 12pstmt.setString(2, student.getName());pstmt.setString(3, student.getEmail()); 至于 dob 属性, MyBatis 会使用 setDate() 方法设置 dob 处占位符位置的值。 MyBaits 会将 java.util.Date 类型转换为 into java.sql.Timestamp 并设值：1pstmt.setTimestamp(4, new Timestamp((student.getDob()).getTime())); 厉害！但 MyBatis 是怎么知道对于 Integer 类型属性使用 setInt() 和 String 类型属性使用 setString()方法呢？其实 MyBatis 是通过使用类型处理器（type handlers）来决定这么做的。MyBatis 对于以下的类型使用内建的类型处理器：所有的基本数据类型、基本类型的包裹类型、 byte[]、java.util.Date、 java.sql.Date、 java,sql.Time、 java.sql.Timestamp、 java 枚举类型等。所以当 MyBatis 发现属性的类型属于上述类型，他会使用对应的类型处理器将值设置到 PreparedStatement 中，同样地，当从 SQL 结果集构建 JavaBean 时，也有类似的过程。那如果我们给了一个自定义的对象类型，来存储存储到数据库呢？示例如下：假设表 STUDENTS 有一个 PHONE 字段，类型为 VARCHAR(15)，而 JavaBean Student 有一个 PhoneNumber 类定义类型的 phoneNumber 属性。123456789101112131415161718192021222324252627282930313233343536373839public class PhoneNumber &#123; private String countryCode; private String stateCode; private String number; public PhoneNumber() &#123; &#125; public PhoneNumber(String countryCode, String stateCode, String number) &#123; this.countryCode = countryCode; this.stateCode = stateCode; this.number = number; &#125; public PhoneNumber(String string) &#123; if (string != null) &#123; String[] parts = string.split(\"-\"); if (parts.length &gt; 0) this.countryCode = parts[0]; if (parts.length &gt; 1) this.stateCode = parts[1]; if (parts.length &gt; 2) this.number = parts[2]; &#125; &#125; public String getAsString() &#123; return countryCode + \"-\" + stateCode + \"-\" + number; &#125; // Setters and getters&#125;public class Student &#123; private Integer id; private String name; private String email; private PhoneNumber phone; // Setters and getters&#125; 1234&lt;insert id=\"insertStudent\" parameterType=\"Student\"&gt; insert into students(name,email,phone) values(#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)&lt;/insert&gt; 这里，phone 参数需要传递给#{phone}；而 phone 对象是 PhoneNumber 类型。然而，MyBatis 并不知道该怎样来处理这个类型的对象。为了让 MyBatis 明白怎样处理这个自定义的 Java 对象类型，如 PhoneNumber，我们可以创建一个自定义的类型处理器，如下所示： MyBatis 提供了抽象类 BaseTypeHandler ，我们可以继承此类创建自定义类型处理器。 12345678910111213141516171819202122232425262728293031packagecom.mybatis3.typehandlers;importjava.sql.CallableStatement;importjava.sql.PreparedStatement;importjava.sql.ResultSet;importjava.sql.SQLException;importorg.apache.ibatis.type.BaseTypeHandler;importorg.apache.ibatis.type.JdbcType;importcom.mybatis3.domain.PhoneNumber;public class PhoneTypeHandler extends BaseTypeHandler&lt;PhoneNumber&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, PhoneNumber parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter.getAsString()); &#125; @Override public PhoneNumber getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return new PhoneNumber(rs.getString(columnName)); &#125; @Override public PhoneNumber getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return new PhoneNumber(rs.getString(columnIndex)); &#125; @Override public PhoneNumber getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return new PhoneNumber(cs.getString(columnIndex)); &#125; &#125; 我们使用 ps.setString()和 rs.getString()方法是因为 phone 列是 VARCHAR 类型。 一旦我们实现了自定义的类型处理器，我们需要在 mybatis-config.xml 中注册它：123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;properties resource=\"application.properties\" /&gt; &lt;typeHandlers&gt; &lt;typeHandler handler=\"com.mybatis3.typehandlers. PhoneTypeHandler\" /&gt; &lt;/typeHandlers&gt;&lt;/configuration&gt; 注册 PhoneTypeHandler 后, MyBatis 就能够将 Phone 类型的对象值存储到 VARCHAR 类型的列上。 全局参数设置 Settings为满足应用特定的需求，MyBatis 默认的全局参数设置可以被覆盖(overridden)掉，如下所示：123456789101112131415&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\" /&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\" /&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\" /&gt; &lt;setting name=\"useColumnLabel\" value=\"true\" /&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\" /&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\" /&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\" /&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25000\" /&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\" /&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\" /&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\" /&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\" /&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode ,toString\" /&gt;&lt;/settings&gt; SQL 映射定义 MappersMapper XML 文件中包含的 SQL 映射语句将会被应用通过使用其 statementid 来执行。我们需要在mybatisconfig.xml 文件中配置 SQL Mapper 文件的位置。123456mappers&gt; &lt;mapper resource=\"com/mybatis3/mappers/StudentMapper.xml\" /&gt; &lt;mapper url=\"file:///D:/mybatisdemo/app/mappers/TutorMapper.xml\" /&gt; &lt;mapper class=\"com.mybatis3.mappers.TutorMapper\" /&gt; &lt;package name=\"com.mybatis3.mappers\" /&gt;&lt;/mappers&gt; 以上每一个 标签的属性有助于从不同类型的资源中加载映射 mapper： resource 属性用来指定在 classpath 中的 mapper 文件。 url 属性用来通过完全文件系统路径或者 web URL 地址来指向 mapper 文件 class 属性用来指向一个 mapper 接口 package 属性用来指向可以找到 Mapper 接口的包名 使用Java API配置MyBatis上一节中，我们已经讨论了各种 MyBatis 配置元素，如 envronments,typeAlias,和 typeHandlers，以及如何使用XML 配置它们。即使你想使用基于 Java API 的 MyBatis 配置，经历上一节的学习是大有好处的，它可以帮你对这些配置元素有更好的理解。在本节中，我们会引用到前一节中描述的一些类。MyBatis 的 SqlSessionFactory 接口除了使用基于 XML 的配置创建外也可以通过 Java API 编程式地被创建。每个在 XML 中配置的元素，都可以编程式的创建。使用 Java API 创建 SqlSessionFactory，代码如下：12345678910111213141516public static SqlSessionFactory getSqlSessionFactory() &#123; SqlSessionFactory sqlSessionFactory = null; try &#123; DataSource dataSource = DataSourceFactory.getDataSource(); TransactionFactory transactionFactory = new JdbcTransactionFactory(); Environment environment = new Environment(\"development\", transactionFactory, dataSource); Configuration configuration = new Configuration(environment); configuration.getTypeAliasRegistry().registerAlias(\"student\", Student.class); configuration.getTypeHandlerRegistry().register(PhoneNumber.class, PhoneTypeHandler.class); configuration.addMapper(StudentMapper.class); sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; return sqlSessionFactory; &#125; 环境配置 Environment我们需要为想使用 MaBatis 连接的每一个数据库创建一个 Enviroment 对象。为了使用每一个环境，我们需要为每一个环境 environment 创建一个 SqlSessionFactory 对象。而创建 Environment 对象，我们需要 java.sql.DataSource和 TransactionFactory 实例。下面让我们看看如何创建 DataSource 和TransactionFactory 对象。 数据源 DataSourceMyBatis 支持三种内建的 DataSource 类型: UNPOOLED, POOLED, 和 JNDI. UNPOOLED 类型的数据源 dataSource 为每一个用户请求创建一个数据库连接。在多用户并发应用中，不建议使用。 POOLED 类型的数据源 dataSource 创建了一个数据库连接池，对用户的每一个请求，会使用缓冲池中的一个可 用 的 Connection 对 象 ， 这 样 可 以 提 高 应 用 的 性 能 。 MyBatis 提 供 了org.apache.ibatis.datasource.pooled.PooledDataSource 实现 javax.sql.DataSource 来创建连接池。 JNDI类型的数据源 dataSource使用了应用服务器的数据库连接池，并且使用 JNDI查找来获取数据库连接。 让我们看一下怎样通过 MyBatis 的 PooledDataSource 获得 DataSource 对象，如下：12345678910public class DataSourceFactory &#123; public static DataSource getDataSource() &#123; String driver = \"com.mysql.jdbc.Driver\"; String url = \"jdbc:mysql://localhost:3306/mybatisdemo\"; String username = \"root\"; String password = \"admin\"; PooledDataSource dataSource = new PooledDataSource(driver, url, username, password); return dataSource; &#125; &#125; 一般在生产环境中，DataSource 会被应用服务器配置，并通过 JNDI 获取 DataSource 对象，如下所示：123456789101112public class DataSourceFactory &#123; public static DataSource getDataSource() &#123; String jndiName = \"java:comp/env/jdbc/MyBatisDemoDS\"; try &#123; InitialContext ctx = new InitialContext(); DataSource dataSource = (DataSource) ctx.lookup(jndiName); return dataSource; &#125; catch (NamingException e) &#123; throw new RuntimeException(e); &#125; &#125; &#125; 当前有一些流行的第三方类库，如 commons-dbcp 和 c3p0 实现了 java.sql.DataSource,你可以使用它们来创建dataSource。 事务工厂 TransactionFactoryMyBatis 支持一下两种 TransactionFactory 实现： JdbcTransactionFactory ManagedTransactionFactory 如果你的应用程序运行在未托管（non-managed）的环境中，你应该使用 JdbcTransactionFactory。123DataSource dataSource = DataSourceFactory.getDataSource();TransactionFactory txnFactory = new JdbcTransactionFactory();Environment environment = new Environment(\"development\", txnFactory, dataSource); 类型别名 typeAliasesMyBatis 提供以下几种通过 Configuration 对象注册类型别名的方法： 根据默认的别名规则，使用一个类的首字母小写、非完全限定的类名作为别名注册，可使用以下代码： 1configuration.getTypeAliasRegistry().registerAlias(Student.class); 指定指定别名注册，可使用以下代码： 1configuration.getTypeAliasRegistry().registerAlias(\"Student\",Student.class); 通过类的完全限定名注册相应类别名，可使用一下代码： 1configuration.getTypeAliasRegistry().registerAlias(\"Student\",\"com.mybatis3.domain.Student\"); 为某一个包中的所有类注册别名，可使用以下代码： 1configuration.getTypeAliasRegistry().registerAliases(\"com.mybatis3.domain\"); 为在 com.mybatis3.domain package 包中所有的继承自 Identifiable 类型的类注册别名，可使用以下代码：1configuration.getTypeAliasRegistry().registerAliases(\"com.mybatis3.domain\",Identifiable.class); 类型处理器 typeHandlersMyBatis 提供了一系列使用 Configuration 对象注册类型处理器（type handler）的方法。我们可以通过以下方式注册自定义的类处理器： 为某个特定的类注册类处理器: 1configuration.getTypeHandlerRegistry().register(PhoneNumber.class, PhoneTypeHandler.class); 注册一个类处理器: 1configuration.getTypeHandlerRegistry().register(PhoneTypeHandler.class); 注册 com.mybatis3.typehandlers 包中的所有类型处理器： 1configuration.getTypeHandlerRegistry().register(\"com.mybatis3.typehandlers\"); 全局参数设置 SettingsMyBatis 提供了一组默认的，能够很好地适用大部分的应用的全局参数设置。然而，你可以稍微调整这些参数，让它更好地满足你应用的需要。你可以使用下列方法将全局参数设置成想要的值。12345678910111213141516171819configuration.setCacheEnabled(true);configuration.setLazyLoadingEnabled(false);configuration.setMultipleResultSetsEnabled(true);configuration.setUseColumnLabel(true);configuration.setUseGeneratedKeys(false);configuration.setAutoMappingBehavior(AutoMappingBehavior.PARTIAL);configuration.setDefaultExecutorType(ExecutorType.SIMPLE);configuration.setDefaultStatementTimeout(25);configuration.setSafeRowBoundsEnabled(false);configuration.setMapUnderscoreToCamelCase(false);configuration.setLocalCacheScope(LocalCacheScope.SESSION);configuration.setAggressiveLazyLoading(true);configuration.setJdbcTypeForNull(JdbcType.OTHER);Set&lt;String&gt; lazyLoadTriggerMethods = new HashSet&lt;String&gt;();lazyLoadTriggerMethods.add(\"equals\");lazyLoadTriggerMethods.add(\"clone\");lazyLoadTriggerMethods.add(\"hashCode\");lazyLoadTriggerMethods.add(\"toString\");configuration.setLazyLoadTriggerMethods(lazyLoadTriggerMethods ); MappersMyBatis 提供了一些使用 Configuration 对象注册 Mapper XML 文件和 Mappe 接口的方法。 添加一个 Mapper 接口，可使用以下代码: configuration.addMapper(StudentMapper.class); 添加 com.mybatis3.mappers 包中的所有 Mapper XML 文件或者 Mapper 接口，可使用以下代码： configuration.addMappers(“com.mybatis3.mappers”); 添加所有 com.mybatis3.mappers 包中的拓展了特定 Mapper 接口的 Maper 接口，如 aseMapper,可使用如下代码： configuration.addMappers(“com.mybatis3.mappers”, BaseMapper.class);Mappers 应该在 typeAliases 和 typeHandler 注册后再添加到 configuration 中。 自定义MyBatis日志MyBatis 使用其内部 LoggerFactory 作为真正的日志类库使用的门面。其内部的 LaggerFactory 会将日志记录任务委托给如下的所示某一个日志实现，日志记录优先级由上到下顺序递减： SLF4J Apache Commons Logging Log4j 2 Log4j JDK logging4如果 MyBatis 未发现上述日志记录实现，则 MyBatis 的日志记录功能无效。如果你的运行环境中，在 classpath 中有多个可用的日志类库，并且你希望 MyBaits 使用某个特定的日志实现，你可以通过调用以下其中一个方法： org.apache.ibatis.logging.LogFactory.useSlf4jLogging(); org.apache.ibatis.logging.LogFactory.useLog4JLogging(); org.apache.ibatis.logging.LogFactory.useLog4J2Logging(); org.apache.ibatis.logging.LogFactory.useJdkLogging(); org.apache.ibatis.logging.LogFactory.useCommonsLogging(); org.apache.ibatis.logging.LogFactory.useStdOutLogging(); 如果你想自定义 MyBatis 日志记录，你应该在调用任何其它方法之前调用以上的其中一个方法。如果你想切换到的日志记录类库在运行时期无效，MyBatis 将会忽略这一请求。 使用XMl配置SQL映射器关系型数据库和 SQL 是经受时间考验和验证的数据存储机制。和其他的 ORM 框架如 Hibernate 不同，MyBatis 鼓励开发者可以直接使用数据库，而不是将其对开发者隐藏，因为这样可以充分发挥数据库服务器所提供的 SQL 语句的巨大威力。与此同时，MyBaits 消除了书写大量冗余代码的痛苦，它使使用 SQL 更容易。在代码里直接嵌套 SQL 语句是很差的编码实践，并且维护起来困难。 MyBaits 使用了映射器配置文件或注解来配置 SQL语句。在本章中，我们会看到具体怎样使用映射器配置文件来配置映射 SQL 语句。本章将涵盖以下话题： 映射器配置文件 和 映射器接口 映射语句 配置 INSERT, UPDATE, DELETE, and SELECT 语句 结果映射 ResultMaps 简单 ResultMaps 使用内嵌 select 语句子查询的一对一映射 使用内嵌的结果集查询的一对一映射 使用内嵌 select 语句子查询的一对多映射 使用内嵌的结果集查询的一对一映射 动态 SQL 语句 If 条件 choose (when, otherwise) 条件 trim (where, set) 条件 foreach 循环 MyBatis 菜谱 映射器配置文件和映射器接口123456789101112public Student findStudentById(Integer studId)&#123; SqlSession sqlSession = MyBatisUtil.getSqlSession(); try&#123; Student student = sqlSession.selectOne(\"com.mybatis3.mappers.StudentMapper.findStudentById\", studId); return student; &#125;finally &#123; sqlSession.close(); &#125;&#125; 我们可以通过字符串（字符串形式为：映射器配置文件所在的包名 namespace + 在文件内定义的语句 id，如上，即包名 com.mybatis3.mappers.StudentMapper 和语句 id findStudentById 组成）调用映射的 SQL 语句，但是这种方式容易出错。你需要检查映射器配置文件中的定义，以保证你的输入参数类型和结果返回类型是有效的。 MyBatis 通过使用映射器 Mapper 接口提供了更好的调用映射语句的方法。一旦我们通过映射器配置文件配置了映射语句，我们可以创建一个完全对应的一个映射器接口，接口名跟配置文件名相同，接口所在包名也跟配置文件所在包名完全一 样 ( 如 StudentMapper.xml 所 在 的 包 名 是 com.mybatis3.mappers ， 对 应 的 接 口 名 就 是com.mybatis3.mappers.StudentMapper.java ）。映射器接口中的方法签名也跟映射器配置文件中完全对应：方法名为配置文件中 id 值；方法参数类型为 parameterType 对应值；方法返回值类型为 returnType 对应值。对于上述的 StudentMapper.xml 文件，我们可以创建一个映射器接口 StudentMapper.java 如下：1234package com.mybatis3.mappers;public interface StudentMapper&#123; Student findStudentById(Integer id);&#125; 在 StudentMapper.xml 映射器配置文件中，其名空间 namespace 应该跟 StudentMapper 接口的完全限定名保持一致。另外， StudentMapper.xml 中语句 id， parameterType， returnType 应该分别和 StudentMapper 接口中的方法名，参数类型，返回值相对应。使用映射器接口我们可以以类型安全的形式调用调用映射语句。如下所示：1234567891011public Student findStudentById(Integer studId)&#123; SqlSession sqlSession = MyBatisUtil.getSqlSession(); try&#123; StudentMapper studentMapper =sqlSession.getMapper(StudentMapper.class); return studentMapper.findStudentById(studId); &#125; finally &#123; sqlSession.close(); &#125;&#125; 即使映射器 Mapper 接口可以以类型安全的方式调用映射语句，但是我们我负责书写正确的，匹配方法名、参数类型、 和返回值的映射器 Mapper 接口。如果映射器 Mapper 接口中的方法和 XML 中的映射语句不能匹配，会在运行期抛出一个异常。实际上，指定 parameterType 是可选的；MyBatis 可以使用反射机制来决定 parameterType。 但是，从配置可读性的角度来看，最好指定parameterType 属性。如果 parameterType 没有被提及，开发者必须查看Mapper XML 配置和 Java 代码了解传递给语句的输入参数的数据类型。 映射语句MyBatis 提供了多种元素来配置不同类型的语句，如 SELECT，INSERT，UPDATE，DELETE。接下来让我们看看如何具体配置映射语句 Insert语句一个 INSERT SQL 语句可以在元素在映射器 XML 配置文件中配置，如下所示：1234&lt;insert id=\"insertStudent\" parameterType=\"Student\"&gt; INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE) VALUES(#&#123;studId&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)&lt;/insert&gt; 这里我们使用一个 ID insertStudent，可以在名空间 com.mybatis3.mappers.StudentMapper.insertStudent 中唯一标识。 parameterType 属性应该是一个完全限定类名或者是一个类型别名（alias） 。我们可以如下调用这个语句：1int count = sqlSession.insert(\"com.mybatis3.mappers.StudentMapper.insertStudent\", student); sqlSession.insert() 方法返回执行 INSERT 语句后所影响的行数。如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示：1234package com.mybatis3.mappers;public interface StudentMapper&#123; int insertStudent(Student student);&#125; 你可以如下调用 insertStudent 映射语句：12StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);int count = mapper.insertStudent(student); 自动生成主键在上述的 INSERT 语句中，我们为可以自动生成（auto-generated）主键的列 STUD_ID 插入值。 我们可以使用useGeneratedKeys 和 keyProperty 属性让数据库生成 auto_increment 列的值，并将生成的值设置到其中一个输入对象属性内，如下所示：12345&lt;insert id=\"insertStudent\" parameterType=\"Student\" useGeneratedKeys=\"true\" keyProperty=\"studId\"&gt; INSERT INTO STUDENTS(NAME, EMAIL, PHONE) VALUES(#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)&lt;/insert&gt; 这里 STUD_ID 列值将会被 MySQL 数据库自动生成，并且生成的值会被设置到 student 对象的 studId 属性上。 StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); mapper.insertStudent(student); 现在可以如下获取插入的 STUDENT 记录的 STUD_ID 的值： int studentId = student.getStudId(); 有些数据库如 Oracle 并不支持 AUTO_INCREMENT 列，其使用序列（SEQUENCE）来生成主键值。假设我们有一个名为 STUD_ID_SEQ 的序列来生成 SUTD_ID 主键值。使用如下代码来生成主键：1234567&lt;insert id=\"insertStudent\" parameterType=\"Student\"&gt; &lt;selectKey keyProperty=\"studId\" resultType=\"int\" order=\"BEFORE\"&gt; SELECT ELEARNING.STUD_ID_SEQ.NEXTVAL FROM DUAL &lt;/selectKey&gt; INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL, PHONE) VALUES(#&#123;studId&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;)&lt;/insert&gt; 这里我们使用了子元素来生成主键值，并将值保存到 Student 对象的 studId 属性上。 属性order=“before”表示 MyBatis 将取得序列的下一个值作为主键值，并且在执行 INSERT SQL 语句之前将值设置到studId 属性上。 我们也可以在获取序列的下一个值时，使用触发器（trigger）来设置主键值，并且在执行 INSERT SQL 语句之前将值设置到主键列上。 如果你采取这样的方式，则对应的 INSERT 映射语句如下所示：1234567&lt;insert id=\"insertStudent\" parameterType=\"Student\"&gt; INSERT INTO STUDENTS(NAME,EMAIL, PHONE) VALUES(#&#123;name&#125;,#&#123;email&#125;,#&#123;phone&#125;) &lt;selectKey keyProperty=\"studId\" resultType=\"int\" order=\"AFTER\"&gt; SELECT ELEARNING.STUD_ID_SEQ.CURRVAL FROM DUAL &lt;/selectKey&gt;&lt;/insert&gt; UPDATE 语句一个 UPDATE SQL 语句可以在元素在映射器 XML 配置文件中配置，如下所示：1234&lt;update id=\"updateStudent\" parameterType=\"Student\"&gt; UPDATE STUDENTS SET NAME=#&#123;name&#125;, EMAIL=#&#123;email&#125;, PHONE=#&#123;phone&#125; WHERE STUD_ID=#&#123;studId&#125;&lt;/update&gt; 我们可以如下调用此语句： int noOfRowsUpdated = sqlSession.update(&quot;com.mybatis3.mappers.StudentMapper.updateStudent&quot;, student); sqlSession.update() 方法返回执行 UPDATE 语句之后影响的行数。 如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示： package com.mybatis3.mappers; public interface StudentMapper{ int updateStudent(Student student); } 你可以使用映射器 Mapper 接口来调用 updateStudent 语句，如下所示： StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); int noOfRowsUpdated = mapper.updateStudent(student); 删除语句一个 DELETE SQL 语句可以在元素在映射器 XML 配置文件中配置，如下所示：123&lt;delete id=\"deleteStudent\" parameterType=\"int\"&gt; DELETE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;&lt;/delete&gt; 我们可以如下调用此语句： int studId = 1; int noOfRowsDeleted = sqlSession.delete(&quot;com.mybatis3.mappers.StudentMapper.deleteStudent&quot;, studId); sqlSession.delete() 方法返回 delete 语句执行后影响的行数。 如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示： package com.mybatis3.mappers; public interface StudentMapper{ int deleteStudent(int studId); } 你可以使用映射器 Mapper 接口来调用 deleteStudent 语句，如下所示： StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); int noOfRowsDeleted = mapper.deleteStudent(studId); SELECT语句MyBatis 真正强大的功能，在于映射 SELECT 查询结果到 JavaBeans 方面的极大灵活性。让我们看看一个简单的 select 查询是如何（在 MyBatis 中）配置的，如下所示：123456&lt;select id=\"findStudentById\" parameterType=\"int\"resultType=\"Student\"&gt; SELECT STUD_ID, NAME, EMAIL, PHONE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 我们可以如下调用此语句： int studId =1; Student student = sqlSession.selectOne(&quot;com.mybatis3.mappers.StudentMapper.findStudentById&quot;, studId); 如果不使用名空间（namespace）和语句 id 来调用映射语句，你可以通过创建一个映射器 Mapper 接口，并以类型安全的方式调用方法，如下所示： package com.mybatis3.mappers; public interface StudentMapper{ Student findStudentById(Integer studId); } 你可以使用映射器 Mapper 接口来调用 updateStudent 语句，如下所示： StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); Student student = mapper.findStudentById(studId); 如果你检查 Student 对象的属性值，你会发现 studId 属性值并没有被 stud_id 列值填充。这是因为 MyBatis 自动对JavaBean 中和列名匹配的属性进行填充。 这就是为什么 name ,email,和 phone 属性被填充，而 studId 属性没有被填充。为了解决这一问题，我们可以为列名起一个可以与 JavaBean 中属性名匹配的别名，如下所示：123456&lt;select id=\"findStudentById\" parameterType=\"int\"resultType=\"Student\"&gt; SELECT STUD_ID AS studId, NAME,EMAIL, PHONE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 现在，Student 这个 Bean 对象中的值将会恰当地被 stud_id,name,email,phone 列填充了。现在，让我们看一下如何执行返回多条结果的 SELECT 语句查询，如下所示：1234&lt;select id=\"findAllStudents\" resultType=\"Student\"&gt; SELECT STUD_ID AS studId, NAME,EMAIL, PHONE FROM STUDENTS&lt;/select&gt; List&lt;Student&gt; students = sqlSession.selectList(&quot;com.mybatis3.mappers.StudentMapper.findAllStudents&quot;); 映射器 Mapper 接口 StudentMapper 可以如下定义： package com.mybatis3.mappers; public interface StudentMapper{ List&lt;Student&gt; findAllStudents(); } 使用上述代码，我们可以如下调用 findAllStudents 语句： StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); List&lt;Student&gt; students = mapper.findAllStudents(); 如果你注意到上述的 SELECT 映射定义，你可以看到，我们为所有的映射语句中的 stud_id 起了别名。我们可以使用 ResultMaps，来避免上述的到处重复别名。我们稍后会继续讨论。除了 java.util.List，你也可以是由其他类型的集合类，如 Set,Map，以及（SortedSet） 。 MyBatis 根据集合的类型，会采用适当的集合实现，如下所示： 对于 List，Collection，Iterable 类型，MyBatis 将返回 java.util.ArrayList 对于 Map 类型，MyBatis 将返回 java.util.HashMap 对于 Set 类型，MyBatis 将返回 java.util.HashSet 对于 SortedSet 类型，MyBatis 将返回 java.util.TreeSet 结果集映射 ResultMapsResultMaps 被用来 将 SQL SELECT 语句的结果集映射到 JavaBeans的属性中。我们可以定义结果集映射 ResultMaps并且在一些 SELECT 语句上引用 resultMap。 MyBatis 的结果集映射 ResultMaps 特性非常强大，你可以使用它将简单的SELECT 语句映射到复杂的一对一和一对多关系的 SELECT 语句上。 简单 ResultMap一个映射了查询结果和 Student JavaBean 的简单的 resultMap 定义如下：1234567891011121314&lt;resultMap id=\"StudentResult\" type=\"com.mybatis3.domain.Student\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;result property=\"phone\" column=\"phone\" /&gt;&lt;/resultMap&gt;&lt;select id=\"findAllStudents\" resultMap=\"StudentResult\"&gt; SELECT * FROM STUDENTS&lt;/select&gt;&lt;select id=\"findStudentById\" parameterType=\"int\" resultMap=\"StudentResult\"&gt; SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 表示 resultMap 的 StudentResult id 值应该在此名空间内是唯一的。并且 type 属性应该是完全限定类名或者是返回类型的别名。&lt;result&gt;子元素被用来将一个 resultset 列映射到 JavaBean 的一个属性中。&lt;id&gt;元素和&lt;result&gt;元素功能相同，不过它被用来映射到唯一标识属性， 用来区分和比较对象 （一般和主键列相对应） 。在&lt;select&gt;语句中，我们使用了 resultMap 属性，而不是 resultType 来引用 StudentResult 映射。 当&lt;select&gt;语句中配置了 resutlMap 属性，MyBatis 会使用此数据库列名与对象属性映射关系来填充 JavaBean 中的属性。resultType 和 resultMap 二者只能用其一，不能同时使用。让我们来看另外一个&lt;select&gt;映射语句定义的例子，怎样将查询结果填充到 HashMap 中。 如下所示：123&lt;select id=\"findStudentById\" parameterType=\"int\" resultType=\"map\"&gt; SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 在上述的&lt;select&gt;语句中，我们将 resultType 配置成 map，即 java.util.HashMap 的别名。在这种情况下，结果集的列名将会作为 Map 中的 key 值，而列值将作为 Map 的 value 值。123456HashMap&lt;String,Object&gt; studentMap = sqlSession.selectOne(\"com.mybatis3.mappers.StudentMapper.findStudentById\", studId);System.out.println(\"stud_id :\"+studentMap.get(\"stud_id\"));System.out.println(\"name :\"+studentMap.get(\"name\"));System.out.println(\"email :\"+studentMap.get(\"email\"));System.out.println(\"phone :\"+studentMap.get(\"phone\")); 让我们再看一个 使用 resultType=”map”,返回多行结果的例子：123&lt;select id=\"findAllStudents\" resultType=\"map\"&gt; SELECT STUD_ID, NAME, EMAIL, PHONE FROM STUDENTS&lt;/select&gt; 由于 resultType=”map”和语句返回多行，则最终返回的数据类型应该是 List&lt;HashMap&lt;String,Object&gt;&gt;，如下所示：12345678910List&lt;HashMap&lt;String, Object&gt;&gt; studentMapList =sqlSession.selectList(\"com.mybatis3.mappers.StudentMapper.findAllStudents\");for(HashMap&lt;String, Object&gt; studentMap : studentMapList)&#123; System.out.println(\"studId :\" + studentMap.get(\"stud_id\")); System.out.println(\"name :\" + studentMap.get(\"name\")); System.out.println(\"email :\" + studentMap.get(\"email\")); System.out.println(\"phone :\" + studentMap.get(\"phone\"));&#125; 拓展 ResultMap我们可以从从另外一个，拓展出一个新的，这样，原先的属性映射可以继承过来，以实现。1234567891011121314&lt;resultMap type=\"Student\" id=\"StudentResult\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;result property=\"phone\" column=\"phone\" /&gt;&lt;/resultMap&gt;&lt;resultMap type=\"Student\" id=\"StudentWithAddressResult\" extends=\"StudentResult\"&gt; &lt;result property=\"address.addrId\" column=\"addr_id\" /&gt; &lt;result property=\"address.street\" column=\"street\" /&gt; &lt;result property=\"address.city\" column=\"city\" /&gt; &lt;result property=\"address.state\" column=\"state\" /&gt; &lt;result property=\"address.zip\" column=\"zip\" /&gt; &lt;result property=\"address.country\" column=\"country\" /&gt;&lt;/resultMap&gt; id 为 StudentWithAddressResult 的 resultMap 拓展了 id 为 StudentResult 的 resultMap。如果你只想映射 Student 数据，你可以使用 id 为 StudentResult 的 resultMap,如下所示：1234&lt;select id=\"findStudentById\" parameterType=\"int\"resultMap=\"StudentResult\"&gt; SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 如果你想将映射 Student 数据和 Address 数据，你可以使用 id 为 StudentWithAddressResult 的resultMap：12345678&lt;select id=\"selectStudentWithAddress\" parameterType=\"int\"resultMap=\"StudentWithAddressResult\"&gt; SELECT STUD_ID, NAME, EMAIL, PHONE, A.ADDR_ID, STREET, CITY, STATE, ZIP, COUNTRY FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON S.ADDR_ID=A.ADDR_ID WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 一对一映射在我们的域模型样例中，每一个学生都有一个与之关联的地址信息。 表 STUDENTS 有一个 ADDR_ID 列，是 ADDRESSES表的外键。STUDENTS 表的样例数据如下所示：123STUD_ID NAME EMAIL PHONE ADDR_ID1 John john@gmail.com 123-456-7890 12 Paul paul@gmail.com 111-222-3333 2 ADDRESSES 表的样例输入如下所示：123ADDR_ID STREET CITY STATE ZIP COUNTRY1 Naperville CHICAGO IL 60515 USA2 Paul CHICAGO IL 60515 USA 下面让我们看一下怎样取 Student 明细和其 Address 明细。Student 和 Address 的 JavaBean 以及映射器 Mapper XML 文件定义如下所示：123456789101112131415161718public class Address&#123; private Integer addrId; private String street; private String city; private String state; private String zip; private String country; // setters &amp; getters&#125;public class Student&#123; private Integer studId; private String name; private String email; private PhoneNumber phone; private Address address; //setters &amp; getters&#125; 123456789101112131415161718192021&lt;resultMap type=\"Student\" id=\"StudentWithAddressResult\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;result property=\"phone\" column=\"phone\" /&gt; &lt;result property=\"address.addrId\" column=\"addr_id\" /&gt; &lt;result property=\"address.street\" column=\"street\" /&gt; &lt;result property=\"address.city\" column=\"city\" /&gt; &lt;result property=\"address.state\" column=\"state\" /&gt; &lt;result property=\"address.zip\" column=\"zip\" /&gt; &lt;result property=\"address.country\" column=\"country\" /&gt;&lt;/resultMap&gt;&lt;select id=\"selectStudentWithAddress\" parameterType=\"int\" resultMap=\"StudentWithAddressResult\"&gt; SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE, ZIP, COUNTRY FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON S.ADDR_ID=A.ADDR_ID WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 我们可以使用圆点记法为内嵌的对象的属性赋值。 在上述的 resultMap 中，Student 的 address 属性使用了圆点记法被赋上了 address 对应列的值。同样地，我们可以访问任意深度的内嵌对象的属性。 我们可以如下访问内嵌对象属性：12345678910//接口定义public interface StudentMapper&#123; Student selectStudentWithAddress(int studId);&#125;//使用int studId = 1;StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);Student student = studentMapper.selectStudentWithAddress(studId);System.out.println(\"Student :\" + student);System.out.println(\"Address :\" + student.getAddress()); 上述样例展示了一对一关联映射的一种方法。然而，使用这种方式映射，如果 address 结果需要在其他的 SELECT 映射语句中映射成 Address 对象，我们需要为每一个语句重复这种映射关系。 MyBatis 提供了更好地实现一对一关联映射的方法：嵌套结果 ResultMap 和嵌套 select 查询语句。接下来，我们将讨论这两种方式。 使用嵌套结果 ResultMap 实现一对一关系映射我们可以使用一个嵌套结果 ResultMap 方式来获取 Student 及其 Address 信息，代码如下：1234567891011121314151617181920212223&lt;resultMap type=\"Address\" id=\"AddressResult\"&gt; &lt;id property=\"addrId\" column=\"addr_id\" /&gt; &lt;result property=\"street\" column=\"street\" /&gt; &lt;result property=\"city\" column=\"city\" /&gt; &lt;result property=\"state\" column=\"state\" /&gt; &lt;result property=\"zip\" column=\"zip\" /&gt; &lt;result property=\"country\" column=\"country\" /&gt; &lt;/resultMap&gt; &lt;resultMap type=\"Student\" id=\"StudentWithAddressResult\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;association property=\"address\" resultMap=\"AddressResult\" /&gt;&lt;/resultMap&gt;&lt;select id=\"findStudentWithAddress\" parameterType=\"int\"resultMap=\"StudentWithAddressResult\"&gt; SELECT STUD_ID, NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE, ZIP, COUNTRY FROM STUDENTS S LEFT OUTER JOIN ADDRESSES A ON S.ADDR_ID=A.ADDR_ID WHERE STUD_ID=#&#123;studId&#125;&lt;/select&gt; 元素被用来导入“有一个”(has-one)类型的关联。 在上述的例子中，我们使用了元素引用了另外的在同一个 XML 文件中定义的。 我们也可以使用定义内联的 resultMap，代码如下所示：1234567891011121314&lt;resultMap type=\"Student\" id=\"StudentWithAddressResult\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;association property=\"address\" javaType=\"Address\"&gt; &lt;id property=\"addrId\" column=\"addr_id\" /&gt; &lt;result property=\"street\" column=\"street\" /&gt; &lt;result property=\"city\" column=\"city\" /&gt; &lt;result property=\"state\" column=\"state\" /&gt; &lt;result property=\"zip\" column=\"zip\" /&gt; &lt;result property=\"country\" column=\"country\" /&gt; &lt;/association&gt;&lt;/resultMap&gt; 使用嵌套结果 ResultMap 方式，关联的数据可以通过简单的查询语句（如果需要的话，需要与 joins 连接操作配合）进行加载。 使用嵌套查询实现一对一关系映射我们可以通过使用嵌套 select 查询来获取 Student 及其 Address 信息，代码如下：12345678910111213141516171819202122232425&lt;resultMap type=\"Address\" id=\"AddressResult\"&gt; &lt;id property=\"addrId\" column=\"addr_id\" /&gt; &lt;result property=\"street\" column=\"street\" /&gt; &lt;result property=\"city\" column=\"city\" /&gt; &lt;result property=\"state\" column=\"state\" /&gt; &lt;result property=\"zip\" column=\"zip\" /&gt; &lt;result property=\"country\" column=\"country\" /&gt;&lt;/resultMap&gt;&lt;select id=\"findAddressById\" parameterType=\"int\"resultMap=\"AddressResult\"&gt; SELECT * FROM ADDRESSES WHERE ADDR_ID=#&#123;id&#125;&lt;/select&gt;&lt;resultMap type=\"Student\" id=\"StudentWithAddressResult\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;association property=\"address\" column=\"addr_id\" select=\"findAddressById\" /&gt;&lt;/resultMap&gt;&lt;select id=\"findStudentWithAddress\" parameterType=\"int\"resultMap=\"StudentWithAddressResult\"&gt; SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;Id&#125;&lt;/select&gt; 在此方式中，元素的 select 属性被设置成了 id 为 findAddressById 的语句。这里，两个分开的SQL 语句将会在数据库中执行，第一个调用 findStudentById 加载 student 信息，而第二个调用 findAddressById 来加载 address 信息。Addr_id 列的值将会被作为输入参数传递给 selectAddressById 语句。我们可以如下调用 findStudentWithAddress 映射语句：1234StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);Student student = mapper.selectStudentWithAddress(studId);System.out.println(student);System.out.println(student.getAddress()); 一对多映射在我们的域模型样例中，一个讲师可以教授一个或者多个课程。 这意味着讲师和课程之间存在一对多的映射关系。我们可以使用元素将 一对多类型的结果 映射到 一个对象集合上。TUTORS 表的样例数据如下：123TUTOR_ID NAME EMAIL PHONE ADDR_ID1 John john@gmail.com 123-456-7890 12 Ying ying@gmail.com 111-222-3333 2 COURSE 表的样例数据如下：1234COURSE_ID NAME DESCRIPTION START_DATE END_DATE TUTOR_ID1 JavaSE Java SE 2013-01-10 2013-02-10 12 JavaEE Java EE 6 2013-01-10 2013-03-10 23 MyBatis MyBatis 2013-01-10 2013-02-20 2 在上述的表数据中，John 讲师教授一个课程，而 Ying 讲师教授两个课程。Course 和 Tutor 的 JavaBean 定义如下：12345678910111213141516171819 public class Course&#123; private Integer courseId; private String name; private String description; private Date startDate; private Date endDate; private Integer tutorId; //setters &amp; getters&#125;public class Tutor&#123; private Integer tutorId; private String name; private String email; private Address address; private List&lt;Course&gt; courses; / setters &amp; getters&#125; 现在让我们看看如何获取讲师信息以及其所教授的课程列表信息。&lt;collection&gt;元素被用来将多行课程结果映射成一个课程 Course 对象的一个集合。 和一对一映射一样，我们可以使用嵌套结果 ResultMap 和嵌套 Select 语句两种方式映射实现一对多映射。 使用内嵌结果 ResultMap 实现一对多映射我们可以使用嵌套结果 resultMap 方式获得讲师及其课程信息，代码如下： 12345678910111213141516171819202122&lt;resultMap type=\"Course\" id=\"CourseResult\"&gt; &lt;id column=\"course_id\" property=\"courseId\" /&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;result column=\"description\" property=\"description\" /&gt; &lt;result column=\"start_date\" property=\"startDate\" /&gt; &lt;result column=\"end_date\" property=\"endDate\" /&gt;&lt;/resultMap&gt;&lt;resultMap type=\"Tutor\" id=\"TutorResult\"&gt; &lt;id column=\"tutor_id\" property=\"tutorId\" /&gt; &lt;result column=\"tutor_name\" property=\"name\" /&gt; &lt;result column=\"email\" property=\"email\" /&gt; &lt;collection property=\"courses\" resultMap=\"CourseResult\" /&gt;&lt;/resultMap&gt;&lt;select id=\"findTutorById\" parameterType=\"int\" resultMap=\"TutorResult\"&gt; SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL, C.COURSE_ID, C.NAME, DESCRIPTION, START_DATE, END_DATE FROM TUTORS T LEFT OUTER JOIN ADDRESSES A ON T.ADDR_ID=A.ADDR_ID LEFT OUTER JOIN COURSES C ON T.TUTOR_ID=C.TUTOR_ID WHERE T.TUTOR_ID=#&#123;tutorId&#125;&lt;/select&gt; 这里我们使用了一个简单的使用了 JOINS 连接的 Select 语句获取讲师及其所教课程信息。 元素的resultMap 属性设置成了 CourseResult，CourseResult 包含了 Course 对象属性与表列名之间的映射。 使用嵌套 Select 语句实现一对多映射我们可以使用嵌套 Select 语句方式获得讲师及其课程信息，代码如下：123456789101112131415161718192021&lt;resultMap type=\"Course\" id=\"CourseResult\"&gt; &lt;id column=\"course_id\" property=\"courseId\" /&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;result column=\"description\" property=\"description\" /&gt; &lt;result column=\"start_date\" property=\"startDate\" /&gt; &lt;result column=\"end_date\" property=\"endDate\" /&gt;&lt;/resultMap&gt;&lt;resultMap type=\"Tutor\" id=\"TutorResult\"&gt; &lt;id column=\"tutor_id\" property=\"tutorId\" /&gt; &lt;result column=\"tutor_name\" property=\"name\" /&gt; &lt;result column=\"email\" property=\"email\" /&gt; &lt;association property=\"address\" resultMap=\"AddressResult\" /&gt; &lt;collection property=\"courses\" column=\"tutor_id\" select=\"findCoursesByTutor\" /&gt;&lt;/resultMap&gt;&lt;select id=\"findTutorById\" parameterType=\"int\" resultMap=\"TutorResult\"&gt; SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL FROM TUTORS T WHERE T.TUTOR_ID=#&#123;tutorId&#125;&lt;/select&gt;&lt;select id=\"findCoursesByTutor\" parameterType=\"int\" resultMap=\"CourseResult\"&gt; SELECT * FROM COURSES WHERE TUTOR_ID=#&#123;tutorId&#125;&lt;/select&gt; 在这种方式中，元素的 select 属性被设置为 id 为 findCourseByTutor 的语句，用来触发单独的 SQL 查询加载课程信息。 tutor_id 这一列值将会作为输入参数传递给 findCouresByTutor 语句。12345678910111213public interface TutorMapper&#123; Tutor findTutorById(int tutorId);&#125; TutorMapper mapper = sqlSession.getMapper(TutorMapper.class); Tutor tutor = mapper.findTutorById(tutorId); System.out.println(tutor); List&lt;Course&gt; courses = tutor.getCourses(); for (Course course : courses) &#123; System.out.println(course); &#125; 嵌套 Select 语句查询会导致 N+1 选择问题。 首先，主查询将会执行（1 次） ，对于主查询返回的每一行，另外一个查询将会被执行（主查询 N 行，则此查询 N 次） 。 对于大型数据库而言，这会导致很差的性能问题。 动态 SQL有时候，静态的 SQL 语句并不能满足应用程序的需求。我们可以根据一些条件，来动态地构建 SQL 语句。例如，在 Web 应用程序中，有可能有一些搜索界面，需要输入一个或多个选项，然后根据这些已选择的条件去执行检索操作。在实现这种类型的搜索功能，我们可能需要根据这些条件 来构建动态的 SQL 语句。 如果用户提供了任何输入条件，我们需要将那个条件 添加到 SQL 语句的 WHERE 子句中。MyBatis 通过使用,,,,元素提供了对构造动态 SQL 语句的高级别支持。 IF条件元素被用来有条件地嵌入 SQL 片段，如果测试条件被赋值为 true，则相应地 SQL 片段将会被添加到 SQL 语句中。假定我们有一个课程搜索界面，设置了 讲师（Tutor）下拉列表框，课程名称（CourseName）文本输入框，开始时间（StartDate）输入框，结束时间（EndDate）输入框，作为搜索条件。假定课讲师下拉列表是必须选的，其他的都是可选的。 当用户点击 搜索 按钮时，我们需要显示符合以下条件的成列表： 特定讲师的课程 课程名 包含输入的课程名称关键字的课程；如果课程名称输入为空，则取所有课程 在开始时间和结束时间段内的课程我们可以对应的映射语句，如下所示： 1234567891011121314151617181920&lt;resultMap type=\"Course\" id=\"CourseResult\"&gt; &lt;id column=\"course_id\" property=\"courseId\" /&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;result column=\"description\" property=\"description\" /&gt; &lt;result column=\"start_date\" property=\"startDate\" /&gt; &lt;result column=\"end_date\" property=\"endDate\" /&gt;&lt;/resultMap&gt;&lt;select id=\"searchCourses\" parameterType=\"hashmap\" resultMap=\"CourseResult\"&gt;&lt;/select&gt;SELECT * FROM COURSESWHERE TUTOR_ID= #&#123;tutorId&#125;&lt;if test=\"courseName != null\"&gt; AND NAME LIKE #&#123;courseName&#125;&lt;/if&gt;&lt;if test=\"startDate != null\"&gt; AND START_DATE &gt;= #&#123;startDate&#125;&lt;/if&gt;&lt;if test=\"endDate != null\"&gt; AND END_DATE &lt;= #&#123;endDate&#125;&lt;/if&gt;&lt;/select&gt; 123456789101112131415161718public interface CourseMapper&#123; List&lt;Course&gt; searchCourses(Map&lt;String, Object&gt; map);&#125;public void searchCourses()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(\"tutorId\", 1); map.put(\"courseName\", \"%java%\"); map.put(\"startDate\", new Date()); CourseMapper mapper = sqlSession.getMapper(CourseMapper.class); List&lt;Course&gt; courses = mapper.searchCourses(map); for (Course course : courses) &#123; System.out.println(course); &#125;&#125; 此处将生成查询语句 SELECT * FROM COURSES WHERE TUTOR_ID= ? AND NAME like ? AND START_DATE &gt;= ?。准备根据给定条件的动态 SQL 查询将会派上用场。 MyBatis 是使用 ONGL（Object Graph Navigation Language）表达式来构建动态 SQL 语句。 choose,when 和 otherwise 条件有时候，查询功能是以查询类别为基础的。 首先，用户需要选择是否希望通过选择 讲师，课程名称，开始时间，或结束时间作为查询条件类别来进行查询，然后根据选择的查询类别，输入相应的参数。在这样的情景中，我们需要只使用其中一种查询类别。MyBatis 提供了&lt;choose&gt;元素支持此类型的 SQL 预处理。现在让我们书写一个适用此情景的 SQL 映射语句。如果没有选择查询类别，则查询开始时间在今天之后的课程，代码如下：1234567891011121314&lt;select id=\"searchCourses\" parameterType=\"hashmap\" resultMap=\"CourseResult\"&gt; SELECT * FROM COURSES &lt;choose&gt; &lt;when test=\"searchBy == 'Tutor'\"&gt; WHERE TUTOR_ID= #&#123;tutorId&#125; &lt;/when&gt; &lt;when test=\"searchBy == 'CourseName'\"&gt; WHERE name like #&#123;courseName&#125; &lt;/when&gt; &lt;otherwise&gt; WHERE TUTOR start_date &gt;= now() &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; MyBatis 计算测试条件的值， 且使用第一个值为 TRUE 的子句。如果没有条件为 true， 则使用&lt;otherwise&gt;内的子句。 Where 条件有时候，所有的查询条件 （criteria）应该是可选的。 在需要使用至少一种查询条件的情况下， 我们应该使用 WHERE子句。并且， 如果有多个条件，我们需要在条件中添加 AND 或 OR。 MyBatis 提供了&lt;where&gt;元素支持这种类型的动态 SQL 语句。在我们查询课程界面，我们假设所有的查询条件是可选的。 进而，当需要提供一个或多个查询条件时，应该改使用WHERE 子句。 1234567891011121314151617&lt;select id=\"searchCourses\" parameterType=\"hashmap\" resultMap=\"CourseResult\"&gt; SELECT * FROM COURSES &lt;where&gt; &lt;if test=\" tutorId != null \"&gt; TUTOR_ID= #&#123;tutorId&#125; &lt;/if&gt; &lt;if test=\"courseName != null\"&gt; AND name like #&#123;courseName&#125; &lt;/if&gt; &lt;if test=\"startDate != null\"&gt; AND start_date &gt;= #&#123;startDate&#125; &lt;/if&gt; &lt;if test=\"endDate != null\"&gt; AND end_date &lt;= #&#123;endDate&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; &lt;where&gt;元素只有在其内部标签有返回内容时才会在动态语句上插入 WHERE 条件语句。 并且，如果 WHERE 子句以AND 或者 OR 打头，则打头的 AND 或 OR 将会被移除。如果 tutor_id 参数值为 null，并且 courseName 参数值不为 null，则&lt;where&gt;标签会将 AND name like #{courseName} 中的 AND 移除掉，生成的 SQL WHERE 子句为：where name like #{courseName}。 条件&lt;trim&gt;元素和&lt;where&gt;元素类似，但是&lt;trim&gt;提供了在添加前缀/后缀 或者 移除前缀/后缀方面提供更大的灵活性。 1234567891011&lt;select id=\"searchCourses\" parameterType=\"hashmap\" resultMap=\"CourseResult\"&gt; SELECT * FROM COURSES &lt;trim prefix=\"WHERE\" prefixOverrides=\"AND | OR\"&gt; &lt;if test=\" tutorId != null \"&gt; TUTOR_ID= #&#123;tutorId&#125; &lt;/if&gt; &lt;if test=\"courseName != null\"&gt; AND name like #&#123;courseName&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; 这里如果任意一个&lt;if&gt;条件为 true，&lt;trim&gt;元素会插入 WHERE,并且移除紧跟 WHERE 后面的 AND 或 OR foreach 循环另外一个强大的动态 SQL 语句构造标签即是。它可以迭代遍历一个数组或者列表，构造 AND/OR 条件或一个 IN 子句。假设我们想找到 tutor_id 为 1，3，6 的讲师所教授的课程，我们可以传递一个 tutor_id 组成的列表给映射语句，然后通过遍历此列表构造动态 SQL。12345678910&lt;select id=\"searchCoursesByTutors\" parameterType=\"map\" resultMap=\"CourseResult\"&gt; SELECT * FROM COURSES &lt;if test=\"tutorIds != null\"&gt; &lt;where&gt; &lt;foreach item=\"tutorId\" collection=\"tutorIds\"&gt; OR tutor_id=#&#123;tutorId&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/if&gt;&lt;/select&gt; 12345678910111213141516171819public interface CourseMapper&#123;List&lt;Course&gt; searchCoursesByTutors(Map&lt;String, Object&gt; map);&#125;public void searchCoursesByTutors()&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); List&lt;Integer&gt; tutorIds = new ArrayList&lt;Integer&gt;(); tutorIds.add(1); tutorIds.add(3); tutorIds.add(6); map.put(\"tutorIds\", tutorIds); CourseMapper mapper = sqlSession.getMapper(CourseMapper.class); List&lt;Course&gt; courses = mapper.searchCoursesByTutors(map); for (Course course : courses) &#123; System.out.println(course); &#125;&#125; 现在让我们来看一下怎样使用&lt;foreach&gt;生成 IN 子句：123456789101112&lt;select id=\"searchCoursesByTutors\" parameterType=\"map\" resultMap=\"CourseResult\"&gt; SELECT * FROM COURSES &lt;if test=\"tutorIds != null\"&gt; &lt;where&gt; tutor_id IN &lt;foreach item=\"tutorId\" collection=\"tutorIds\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;tutorId&#125; &lt;/foreach&gt; &lt;/where&gt; &lt;/if&gt;&lt;/select&gt; set条件&lt;set&gt;元素和&lt;where&gt;元素类似，如果其内部条件判断有任何内容返回时，他会插入 SET SQL 片段。123456789&lt;update id=\"updateStudent\" parameterType=\"Student\"&gt; update students &lt;set&gt; &lt;if test=\"name != null\"&gt;name=#&#123;name&#125;,&lt;/if&gt; &lt;if test=\"email != null\"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test=\"phone != null\"&gt;phone=#&#123;phone&#125;,&lt;/if&gt; &lt;/set&gt; where stud_id=#&#123;id&#125;&lt;/update&gt; 这里，如果条件返回了任何文本内容，&lt;set&gt;将会插入 set 关键字和其文本内容，并且会剔除将末尾的 “，”。在上述的例子中，如果 phone!=null,&lt;set&gt;将会让会移除 phone=#{phone}后的逗号“,”，生成 set phone=#{phone} 。 MyBaits 食谱除了简化数据库编程外，MyBatis 还提供了各种功能，这些对实现一些常用任务非常有用，比如按页加载表数据，存取 CLOB/BLOB 类型的数据，处理枚举类型值，等等。让我们来看看其中一些特性吧。 处理枚举类型MyBatis 支持开箱方式持久化 enum 类型属性。假设 STUDENTS 表中有一列 gender（性别）类型为 varchar，存储”MALE”或者“FEMALE”两种值。并且，Student 对象有一个 enum 类型的 gender 属性，如下所示： 12345public enum Gender&#123; FEMALE, MALE&#125; 默认情况下，MyBatis 使用 EnumTypeHandler 来处理 enum 类型的 Java 属性，并且将其存储为 enum 值的名称。 你不需要为此做任何额外的配置。你可以可以向使用基本数据类型属性一样使用 enum 类型属性，代码如下：12345678910public class Student&#123; private Integer id; private String name; private String email; private PhoneNumber phone; private Address address; private Gender gender; //setters and getters&#125; 12345&lt;insert id=\"insertStudent\" parameterType=\"Student\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into students(name,email,addr_id, phone,gender) values(#&#123;name&#125;,#&#123;email&#125;,#&#123;address.addrId&#125;,#&#123;phone&#125;,#&#123;gender&#125;)&lt;/insert&gt; 当你执行 insertStudent 语句的时候， MyBatis 会取 Gender 枚举（FEMALE/MALE） 的名称， 然后将其存储到 GENDER列中。如果你希望存储原 enum 的顺序位置，而不是 enum 名，，你需要明确地配置它。如果你想存储 FEMALE 为 0， MALE 为 1 到 gender 列中，你需要在 mybatis-config.xml 文件中配置EnumOrdinalTypeHandler:12&lt;typeHandler handler=\"org.apache.ibatis.type.EnumOrdinalTypeHandler\"javaType=\"com.mybatis3.domain.Gender\"/&gt; 使用顺序位置为值存储到数据库时要当心。 顺序值是根据 enum 中的声明顺序赋值的。如果你改变了 Gender enum 的声明顺序，则数据库存储的数据和此顺序值就不匹配了。 处理 CLOB/BLOB 类型数据MyBatis 提供了内建的对 CLOB/BLOB 类型列的映射处理支持。假设我们有如下的表结构来存储学生和讲师的照片和简介信息：12345678CREATE TABLE USER_PICS(ID INT(11) NOT NULL AUTO_INCREMENT,NAME VARCHAR(50) DEFAULT NULL,PIC BLOB,BIO LONGTEXT,PRIMARY KEY (ID)) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=LATIN1; 这里，照片可以是 PNG,JPG 或其他格式的。简介信息可以是学生或者讲师的漫长的人生经历。 默认情况下，MyBatis将 CLOB 类型的列映射到 java.lang.String 类型上、 而把 BLOB 列映射到 byte[] 类型上。 12345678public class UserPic&#123; private int id; private String name; private byte[] pic; private String bio; //setters &amp; getters&#125; 创建 UserPicMapper.xml 文件，配置映射语句，代码如下： 1234567&lt;insert id=\"insertUserPic\" parameterType=\"UserPic\"&gt; INSERT INTO USER_PICS(NAME, PIC,BIO) VALUES(#&#123;name&#125;,#&#123;pic&#125;,#&#123;bio&#125;)&lt;/insert&gt;&lt;select id=\"getUserPic\" parameterType=\"int\" resultType=\"UserPic\"&gt; SELECT * FROM USER_PICS WHERE ID=#&#123;id&#125;&lt;/select&gt; 下列的 insertUserPic()展示了如何将数据插入到 CLOB/BLOB 类型的列上：1234567891011121314151617181920212223242526public void insertUserPic() &#123; byte[] pic = null; try &#123; File file = new File(\"C:\\\\Images\\\\UserImg.jpg\"); InputStream is = new FileInputStream(file); pic = new byte[is.available()]; is.read(pic); is.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String name = \"UserName\"; String bio = \"put some lenghty bio here\"; UserPic userPic = new UserPic(0, name, pic, bio); SqlSession sqlSession = MyBatisUtil.openSession(); try &#123; UserPicMapper mapper = sqlSession.getMapper(UserPicMapper.class); mapper.insertUserPic(userPic); sqlSession.commit(); &#125; finally &#123; sqlSession.close(); &#125; &#125; 下面的 getUserPic()方法展示了怎样将 CLOB 类型数据读取到 String 类型，BLOB 类型数据读取成 byte[]属性：1234567891011121314151617181920public void getUserPic() &#123; UserPic userPic = null; SqlSession sqlSession = MyBatisUtil.openSession(); try &#123; UserPicMapper mapper = sqlSession.getMapper(UserPicMapper.class); userPic = mapper.getUserPic(1); &#125; finally &#123; sqlSession.close(); &#125; byte[] pic = userPic.getPic(); try &#123; OutputStream os = new FileOutputStream(new File(\"C:\\\\Images\\\\UserImage_FromDB.jpg\")); os.write(pic); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 传入多个输入参数MyBatis 中的映射语句有一个 parameterType 属性来制定输入参数的类型。如果我们想给映射语句传入多个参数的话，我们可以将所有的输入参数放到 HashMap 中，将 HashMap 传递给映射语句。MyBatis 还提供了另外一种传递多个输入参数给映射语句的方法。假设我们想通过给定的 name 和 email 信息查找学生信息，定义查询接口如下：1234Public interface StudentMapper&#123; List&lt;Student&gt; findAllStudentsByNameEmail(String name, String email);&#125; MyBatis 支持 将多个输入参数传递给映射语句，并以#{param}的语法形式引用它们：1234&lt;select id=\"findAllStudentsByNameEmail\" resultMap=\"StudentResult\"&gt; select stud_id, name,email, phone from Students where name=#&#123;param1&#125; and email=#&#123;param2&#125;&lt;/select&gt; 这里#{param1}引用第一个参数 name，而#{param2}引用了第二个参数 email。12StudentMapper studentMapper = sqlSession.getMapper(StudentMapper.class);studentMapper.findAllStudentsByNameEmail(name, email); 多行结果集映射成 Map如果你有一个映射语句返回多行记录，并且你想以 HashMap 的形式存储记录的值，使用记录列名作为 key 值，而记录对应值或为 value 值。我们可以使用 sqlSession.selectMap(),如下所示： 123&lt;select id=\" findAllStudents\" resultMap=\"StudentResult\"&gt; select * from Students&lt;/select&gt; 1Map&lt;Integer, Student&gt; studentMap = sqlSession.selectMap(\"com.mybatis3.mappers.StudentMapper.findAllStudents\", \"studId\"); 这里 studentMap 将会将 studId 作为 key 值，而 Student 对象作为 value 值。 使用 RowBounds 对结果集进行分页有时候，我们会需要跟海量的数据打交道，比如一个有数百万条数据级别的表。 由于计算机内存的现实我们不可能一次性加载这么多数据，我们可以获取到数据的一部分。特别是在 Web 应用程序中，分页机制被用来以一页一页的形式展示海量的数据。MyBatis 可以使用 RowBounds 逐页加载表数据。 RowBounds 对象可以使用 offset 和 limit 参数来构建。 参数offset 表示开始位置，而 limit 表示要取的记录的数目。假设如果你想每页加载并显示 25 条学生的记录，你可以使用如下的代码：123&lt;select id=\"findAllStudents\" resultMap=\"StudentResult\"&gt; select * from Students&lt;/select&gt; 然后，你可以加载如下加载第一页数据（前 25 条）: 123int offset =0 , limit =25;RowBounds rowBounds = new RowBounds(offset, limit);List&lt;Student&gt; = studentMapper.getStudents(rowBounds); 若要展示第二页，使用 offset=25,limit=25;第三页，则为 offset=50，limit=25。 使用 ResultSetHandler 自定义结果集 ResultSet 处理MyBatis 在将查询结果集映射到 JavaBean 方面提供了很大的选择性。 但是，有时候我们会遇到由于特定的目的，需要我们自己处理 SQL 查询结果的情况。 MyBatis 提供了 ResultHandler 插件形式允许我们以任何自己喜欢的方式处理结果集 ResultSet。假设我们想从学生的 stud_id 被用作 key，而 name 被用作 value 的 HashMap 中获取到 student 信息。 mybatis-3.2.2 并不支持使用 resultMap 配置将查询的结果集映射成一个属性为key，而另外属性为 value 的 HashMap。sqlSession.selectMap()则可以返回 以给定列为 key，记录对象为 value 的 map。我们不能将其配置成使用其中一个属性作为 key，而另外的属性作为 value。 对于 sqlSession.select()方法，我们可以传递给它一个 ResultHandler 的实现，它会被调用来处理 ResultSet的每一条记录。1234public interface ResultHandler&#123; void handleResult(ResultContext context);&#125; 现在然我们来看一下怎么使用 ResultHandler 来处理结果集 ResultSet，并返回自定义化的结果。12345678910111213141516171819202122public Map&lt;Integer, String&gt; getStudentIdNameMap() &#123; final Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); SqlSession sqlSession = MyBatisUtil.openSession(); try &#123; sqlSession.select(\"com.mybatis3.mappers.StudentMapper.findAllStudents\", new ResultHandler()&#123; @Override public void handleResult(ResultContext context)&#123; Student student = (Student) context.getResultObject(); map.put(student.getStudId(), student.getName()); &#125; &#125; ); &#125; finally &#123; sqlSession.close(); &#125; return map; &#125; 在上述的代码中，我们提供了匿名内部 ResultHandler 实现类，在 handleResult()方法中，我们使用context.getResultObject()获取当前的 result 对象，即 Student 对象，因为我们定义了 findAllStudent 映射语句的 resultMap=”studentResult“。对查询返回的每一行都会调用 handleResult()方法，并且我们从 Student 对象中取出 studId 和 name，将其放到 map 中。 缓存将从数据库中加载的数据缓存到内存中，是很多应用程序为了提高性能而采取的一贯做法。 MyBatis 对通过映射的SELECT 语句加载的查询结果提供了内建的缓存支持。默认情况下，启用一级缓存；即，如果你使用同一个 SqlSession接口对象调用了相同的 SELECT 语句，则直接会从缓存中返回结果，而不是再查询一次数据库。我们可以在 SQL 映射器 XML 配置文件中使用&lt;cache /&gt;元素添加全局二级缓存。当你加入了&lt;cache /&gt;元素，将会出现以下情况： 所有的在映射语句文件定义的&lt;select&gt;语句的查询结果都会被缓存 所有的在映射语句文件定义的&lt;insert&gt;,&lt;update&gt; 和&lt;delete&gt;语句将会刷新缓存 缓存根据最近最少被使用（Least Recently Used，LRU）算法管理 缓存不会被任何形式的基于时间表的刷新（没有刷新时间间隔） ，即不支持定时刷新机制 缓存将存储 1024 个 查询方法返回的列表或者对象的引用 缓存会被当作一个读/写缓存。 这是指检索出的对象不会被共享，并且可以被调用者安全地修改，不会其他潜在的调用者或者线程的潜在修改干扰。（即，缓存是线程安全的）你也可以通过复写默认属性来自定义缓存的行为，如下所示：1&lt;cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/&gt; 以下是对上述属性的描述： eviction:此处定义缓存的移除机制。默认值是 LRU，其可能的值有：LRU（least recently used,最近最少使用）,FIFO(first in first out,先进先出)，SOFT(soft reference,软引用)，WEAK（weakreference,弱引用） 。 flushInterval:定义缓存刷新间隔，以毫秒计。默认情况下不设置。所以不使用刷新间隔，缓存 cache 只有调用语句的时候刷新。 size:此表示缓存 cache 中能容纳的最大元素数。默认值是 1024，你可以设置成任意的正整数。 readOnly:一个只读的缓存 cache 会对所有的调用者返回被缓存对象的同一个实例（实际返回的是被返回对象的一份引用）。一个读/写缓存 cache 将会返回被返回对象的一分拷贝（通过序列化） 。默认情况下设置为 false。 可能的值有 false 和 true。一个缓存的配置和缓存实例被绑定到映射器配置文件所在的名空间（namespace）上，所以在相同名空间内的所有语句被绑定到一个 cache 中。 默认的映射语句的 cache 配置如下： 1234&lt;select ... flushCache=\"false\" useCache=\"true\"/&gt;&lt;insert ... flushCache=\"true\"/&gt;&lt;update ... flushCache=\"true\"/&gt;&lt;delete ... flushCache=\"true\"/&gt; 你可以为任意特定的映射语句复写默认的 cache 行为；例如，对一个 select 语句不使用缓存，可以设置useCache=“false”。除了内建的缓存支持，MyBatis 也提供了与第三方缓存类库如 Ehcache，OSCache，Hazelcast 的集成支持。 你可以在 MyBatis 官方网站 https://code.google.com/p/mybatis/wiki/Caches 上找到关于继承第三方缓存类库的更多信息。 使用注解配置 SQL 映射器在上一章，我们看到了我们是怎样在映射器 Mapper XML 配置文件中配置映射语句的。 MyBatis 也支持使用注解来配置映射语句。当我们使用基于注解的映射器接口时，我们不再需要在 XML 配置文件中配置了。 如果你愿意，你也可以同时使用基于 XML 和基于注解的映射语句。本章将涵盖以下话题： 在映射器 Mapper 接口上使用注解 映射语句 @Insert， @Update， @Delete,@SeelctStatements 结果映射 一对一映射 一对多映射 动态 SQL @SelectProvider @InsertProvider @UpdateProvider @DeleteProvider 在映射器 Mapper 接口上使用注解MyBatis 对于大部分的基于 XML 的映射器元素（包括&lt;select&gt;,&lt;update&gt;）提供了对应的基于注解的配置项。然而在某些情况下，基于注解配置 还不能支持基于 XML 的一些元素。 映射语句MyBatis 提供了多种注解来支持不同类型的语句(statement)如 SELECT,INSERT,UPDATE,DELETE。 让我们看一下具体怎样配置映射语句。 @Insert 我们可以使用@Insert 注解来定义一个 INSERT 映射语句：1234567package com.mybatis3.mappers;public interface StudentMapper&#123; @Insert(\"INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,ADDR_ID, PHONE) VALUES(#&#123;studId&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;address.addrId&#125;,#&#123;phone&#125;)\") int insertStudent(Student student);&#125; 使用了@Insert 注解的 insertMethod()方法将返回 insert 语句执行后影响的行数。 自动生成主键在上一章中我们讨论过主键列值可以自动生成。我们可以使用@Options 注解的 userGeneratedKeys 和keyProperty 属性让数据库产生 auto_increment（自增长）列的值，然后将生成的值设置到输入参数对象的属性中。 1234@Insert(\"INSERT INTO STUDENTS(NAME,EMAIL,ADDR_ID, PHONE) VALUES(#&#123;name&#125;,#&#123;email&#125;,#&#123;address.addrId&#125;,#&#123;phone&#125;)\")@Options(useGeneratedKeys = true, keyProperty = \"studId\")int insertStudent(Student student); 这里 STUD_ID 列值将会通过 MySQL 数据库自动生成。并且生成的值将会被设置到 student 对象的 studId 属性中。123StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);mapper.insertStudent(student);int studentId = student.getStudId(); 有一些数据库如 Oracle，并不支持 AUTO_INCREMENT 列属性，它使用序列（SEQUENCE）来产生主键的值。 我们可以使用@SelectKey 注解来为任意 SQL 语句来指定主键值，作为主键列的值。假设我们有一个名为 STUD_ID_SEQ 的序列来生成 STUD_ID 主键值。12345@Insert(\"INSERT INTO STUDENTS(STUD_ID,NAME,EMAIL,ADDR_ID, PHONE)VALUES(#&#123;studId&#125;,#&#123;name&#125;,#&#123;email&#125;,#&#123;address.addrId&#125;,#&#123;phone&#125;)\")@SelectKey(statement=\"SELECT STUD_ID_SEQ.NEXTVAL FROM DUAL\",keyProperty=\"studId\", resultType=int.class, before=true)int insertStudent(Student student); 这里我们使用了@SelectKey 来生成主键值，并且存储到了 student 对象的 studId 属性上。 由于我们设置了before=true,该语句将会在执行 INSERT 语句之前执行。如果你使用序列作为触发器来设置主键值，我们可以在 INSERT 语句执行后，从 sequence_name.currval 获取数据库产生的主键值。 12345@Insert(\"INSERT INTO STUDENTS(NAME,EMAIL,ADDR_ID, PHONE)VALUES(#&#123;name&#125;,#&#123;email&#125;,#&#123;address.addrId&#125;,#&#123;phone&#125;)\")@SelectKey(statement=\"SELECT STUD_ID_SEQ.CURRVAL FROM DUAL\",keyProperty=\"studId\", resultType=int.class, before=false)int insertStudent(Student student); @Update 我们可以使用@Update 注解来定义一个 UPDATE 映射语句，如下所示：123@Update(\"UPDATE STUDENTS SET NAME=#&#123;name&#125;, EMAIL=#&#123;email&#125;,PHONE=#&#123;phone&#125; WHERE STUD_ID=#&#123;studId&#125;\")int updateStudent(Student student); 使用了@Update 的 updateStudent()方法将会返回执行了 update 语句后影响的行数。12StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);int noOfRowsUpdated = mapper.updateStudent(student); @Delete 我们可以使用@Delete 注解来定义一个 DELETE 映射语句，如下所示：12@Delete(\"DELETE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;\")int deleteStudent(int studId); @Select 我们可以使用@ Select 注解来定义一个 SELECT 映射语句。让我们看一下怎样使用注解配置一个简单的 select 查询。1234567package com.mybatis3.mappers;public interface StudentMapper&#123; @Select(\"SELECT STUD_ID AS STUDID, NAME, EMAIL, PHONE FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;\") Student findStudentById(Integer studId);&#125; 为了将列名和 Student bean 属性名匹配，我们为 stud_id 起了一个 studId 的别名。如果返回了多行结果，将抛出 TooManyResultsException 异常。 结果映射我们可以将查询结果通过别名或者是@Results 注解与 JavaBean 属性映射起来。现在让我们看看怎样使用@Results 注解将指定列于指定 JavaBean 属性映射器来，执行 SELECT 查询的：12345678910111213package com.mybatis3.mappers;public interface StudentMapper&#123; @Select(\"SELECT * FROM STUDENTS\") @Results( &#123; @Result(id = true, column = \"stud_id\", property = \"studId\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"email\", property = \"email\"), @Result(column = \"addr_id\", property = \"address.addrId\") &#125;) List&lt;Student&gt; findAllStudents();&#125; @Results 注解和映射器 XML 配置文件元素想对应。 然而，MyBatis3.2.2 不能为@Results 注解赋予一个 ID。 所以，不像元素，我们不应在不同的映射语句中重用@Results 声明。这意味着即使@Results注解完全相同，我们也需要(在不同的映射接口中)重复@Results 声明。 例如，看下面的 findStudentById()和 findAllStudents()方法：12345678910111213141516171819@Select(\"SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;\")@Results(&#123; @Result(id = true, column = \"stud_id\", property = \"studId\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"email\", property = \"email\"), @Result(column = \"addr_id\", property = \"address.addrId\")&#125;)Student findStudentById(int studId);@Select(\"SELECT * FROM STUDENTS\")@Results(&#123; @Result(id = true, column = \"stud_id\", property = \"studId\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"email\", property = \"email\"), @Result(column = \"addr_id\", property = \"address.addrId\")&#125;)List&lt;Student&gt; findAllStudents(); 这里两个语句的@Results 配置完全相同，但是我必须得重复它。 这里有一个解决方法。 我们可以创建一个映射器Mapper 配置文件， 然后配置元素，然后使用@ResultMap 注解引用此。在 StudentMapper.xml 中定义一个 ID 为 StudentResult 的。12345678&lt;mapper namespace=\"com.mybatis3.mappers.StudentMapper\"&gt; &lt;resultMap type=\"Student\" id=\"StudentResult\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;result property=\"phone\" column=\"phone\" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 在 StudentMapper.java 中，使用@ResultMap 引用名为 StudentResult 的 resultMap。12345678910public interface StudentMapper&#123; @Select(\"SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125;\") @ResultMap(\"com.mybatis3.mappers.StudentMapper.StudentResult\") Student findStudentById(int studId); @Select(\"SELECT * FROM STUDENTS\") @ResultMap(\"com.mybatis3.mappers.StudentMapper.StudentResult\") List&lt;Student&gt; findAllStudents();&#125; 一对一映射MyBatis 提供了@One 注解来使用嵌套 select 语句（Nested-Select）加载一对一关联查询数据。让我们看看怎样使用@One 注解获取学生及其地址信息。123456789101112131415161718public interface StudentMapper&#123; @Select(\"SELECT ADDR_ID AS ADDRID, STREET, CITY, STATE, ZIP, COUNTRY FROM ADDRESSES WHERE ADDR_ID=#&#123;id&#125;\") Address findAddressById(int id); @Select(\"SELECT * FROM STUDENTS WHERE STUD_ID=#&#123;studId&#125; \") @Results( &#123; @Result(id = true, column = \"stud_id\", property = \"studId\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"email\", property = \"email\"), @Result(property = \"address\", column = \"addr_id\", one = @One(select = \"com.mybatis3.mappers.StudentMapper. findAddressById\")) &#125;) Student selectStudentWithAddress(int studId);&#125; 这里我们使用了@One 注解的 select 属性来指定一个使用了完全限定名的方法上，该方法会返回一个 Address 对象。 使用 column=”addr_id”,则 STUEDNTS 表中列 addr_id 的值将会作为输入参数传递给findAddressById()方法。如果@One SELECT 查询返回了多行结果，则会抛出 TooManyResultsException 异常。123456int studId = 1;StudentMapper studentMapper =sqlSession.getMapper(StudentMapper.class);Student student = studentMapper.selectStudentWithAddress(studId);System.out.println(\"Student :\"+student);System.out.println(\"Address :\"+student.getAddress()); 在第三章，使用 XML 配置 SQL 映射器中我们讨论过，我们可以通过基于 XML 的映射器配置， 使用嵌套结果 ResultMap来加载一对一关联的查询。 而 MyBatis3.2.2 版本，并没有对应的注解支持。但是我们可以在映射器 Mapper 配置文件中配置并且使用@ResultMap 注解来引用它。在 StudentMapper.xml 中配置，如下所示：12345678910111213141516&lt;mapper namespace=\"com.mybatis3.mappers.StudentMapper\"&gt; &lt;resultMap type=\"Address\" id=\"AddressResult\"&gt; &lt;id property=\"addrId\" column=\"addr_id\" /&gt; &lt;result property=\"street\" column=\"street\" /&gt; &lt;result property=\"city\" column=\"city\" /&gt; &lt;result property=\"state\" column=\"state\" /&gt; &lt;result property=\"zip\" column=\"zip\" /&gt; &lt;result property=\"country\" column=\"country\" /&gt; &lt;/resultMap&gt; &lt;resultMap type=\"Student\" id=\"StudentWithAddressResult\"&gt; &lt;id property=\"studId\" column=\"stud_id\" /&gt; &lt;result property=\"name\" column=\"name\" /&gt; &lt;result property=\"email\" column=\"email\" /&gt; &lt;association property=\"address\" resultMap=\"AddressResult\" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 123456789public interface StudentMapper&#123; @Select(\"select stud_id, name, email, a.addr_id, street, city, state, zip, country\" + \" FROM students s left outer join addresses a on s.addr_id=a.addr_id\" + \" where stud_id=#&#123;studId&#125; \") @ResultMap(\"com.mybatis3.mappers.StudentMapper. StudentWithAddressResult\") Student selectStudentWithAddress(int id);&#125; 一对多映射MyBatis 提供了@Many 注解，用来使用嵌套 Select 语句加载一对多关联查询。现在让我们看一下如何使用@Many 注解获取一个讲师及其教授课程列表信息：123456789101112131415161718192021222324252627282930313233public interface TutorMapper&#123; @Select(\"select addr_id as addrId, street, city, state, zip, country from addresses where addr_id=#&#123;id&#125;\") Address findAddressById(int id); @Select(\"select * from courses where tutor_id=#&#123;tutorId&#125;\") @Results( &#123; @Result(id = true, column = \"course_id\", property = \"courseId\"), @Result(column = \"name\", property = \"name\"), @Result(column = \"description\", property = \"description\"), @Result(column = \"start_date\" property = \"startDate\"), @Result(column = \"end_date\" property = \"endDate\") &#125;) List&lt;Course&gt; findCoursesByTutorId(int tutorId); @Select(\"SELECT tutor_id, name as tutor_name, email, addr_id FROM tutors where tutor_id=#&#123;tutorId&#125;\") @Results( &#123; @Result(id = true, column = \"tutor_id\", property = \"tutorId\"), @Result(column = \"tutor_name\", property = \"name\"), @Result(column = \"email\", property = \"email\"), @Result(property = \"address\", column = \"addr_id\", one = @One(select = \" com.mybatis3. mappers.TutorMapper.findAddressById\")), @Result(property = \"courses\", column = \"tutor_id\", many = @Many(select = \"com.mybatis3.mappers.TutorMapper. findCoursesByTutorId\")) &#125;) Tutor findTutorById(int tutorId);&#125; 这里我们使用了@Many 注解的 select 属性来指向一个完全限定名称的方法，该方法将返回一个List&lt;Course&gt;对象。使用 column=”tutor_id”，TUTORS 表中的 tutor_id 列值将会作为输入参数传递给 findCoursesByTutorId()方法。在第三章，使用 XML 配置 SQL 映射器中我们讨论过，我们可以通过基于 XML 的映射器配置， 使用嵌套结果 ResultMap来加载一对多关联的查询。 而 MyBatis3.2.2 版本，并没有对应的注解支持。但是我们可以在映射器 Mapper 配置文件中配置&lt;resultMap&gt;并且使用@ResultMap 注解来引用它。在 TutorMapper.xml 中配置&lt;resultMap&gt;,如下所示：123456789101112131415161718192021222324&lt;mapper namespace=\"com.mybatis3.mappers.TutorMapper\"&gt; &lt;resultMap type=\"Address\" id=\"AddressResult\"&gt; &lt;id property=\"addrId\" column=\"addr_id\" /&gt; &lt;result property=\"street\" column=\"street\" /&gt; &lt;result property=\"city\" column=\"city\" /&gt; &lt;result property=\"state\" column=\"state\" /&gt; &lt;result property=\"zip\" column=\"zip\" /&gt; &lt;result property=\"country\" column=\"country\" /&gt; &lt;/resultMap&gt; &lt;resultMap type=\"Course\" id=\"CourseResult\"&gt; &lt;id column=\"course_id\" property=\"courseId\" /&gt; &lt;result column=\"name\" property=\"name\" /&gt; &lt;result column=\"description\" property=\"description\" /&gt; &lt;result column=\"start_date\" property=\"startDate\" /&gt; &lt;result column=\"end_date\" property=\"endDate\" /&gt; &lt;/resultMap&gt; &lt;resultMap type=\"Tutor\" id=\"TutorResult\"&gt; &lt;id column=\"tutor_id\" property=\"tutorId\" /&gt; &lt;result column=\"tutor_name\" property=\"name\" /&gt; &lt;result column=\"email\" property=\"email\" /&gt; &lt;association property=\"address\" resultMap=\"AddressResult\" /&gt; &lt;collection property=\"courses\" resultMap=\"CourseResult\" /&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 12345678910public interface TutorMapper&#123; @Select(\"SELECT T.TUTOR_ID, T.NAME AS TUTOR_NAME, EMAIL, A.ADDR_ID, STREET, CITY, STATE, ZIP, COUNTRY, COURSE_ID, C.NAME, DESCRIPTION, START_DATE, END_DATE FROM TUTORS T LEFT OUTER JOIN ADDRESSES A ON T.ADDR_ID=A.ADDR_ID LEFT OUTER JOIN COURSES C ON T.TUTOR_ID=C.TUTOR_ID WHERE T.TUTOR_ID=#&#123;tutorId&#125;\") @ResultMap(\"com.mybatis3.mappers.TutorMapper.TutorResult\") Tutor selectTutorById(int tutorId);&#125; 动态 SQL有 时 候 我 们 需 要 根 据 输 入 条 件 动 态 地 构 建 SQL 语 句 。 MyBatis 提 供 了 各 种 注 解 如@InsertProvider,@UpdateProvider,@DeleteProvider 和@SelectProvider，来帮助构建动态 SQL 语句，然后让MyBatis 执行这些 SQL 语句。 @SelectProvider现在让我们来看一个使用@SelectProvider 注解来创建一个简单的 SELECT 映射语句的例子。创建一个 TutorDynaSqlProvider.java 类，以及 findTutorByIdSql()方法，如下所示：12345678910package com.mybatis3.sqlproviders;import org.apache.ibatis.jdbc.SQL;public class TutorDynaSqlProvider&#123; public String findTutorByIdSql(int tutorId) &#123; return \"SELECT TUTOR_ID AS tutorId, NAME, EMAIL FROM TUTORS WHERE TUTOR_ID=\" + tutorId; &#125;&#125; 在 TutorMapper.java 接口中创建一个映射语句，如下：12@SelectProvider(type=TutorDynaSqlProvider.class, method=\"findTutorByIdSql\")Tutor findTutorById(int tutorId); 这里我们使用了@SelectProvider 来指定了一个类，及其内部的方法，用来提供需要执行的 SQL 语句。但是使用字符串拼接的方法唉构建 SQL 语句是非常困难的，并且容易出错。所以 MyBaits 提供了一个 SQL 工具类不使用字符串拼接的方式，简化构造动态 SQL 语句。现在，让我们看看如何使用 org.apache.ibatis.jdbc.SQL 工具类来准备相同的 SQL 语句。123456789101112131415package com.mybatis3.sqlproviders;import org.apache.ibatis.jdbc.SQL;public class TutorDynaSqlProvider&#123; public String findTutorByIdSql(final int tutorId) &#123; return new SQL()&#123; &#123; SELECT(\"tutor_id as tutorId, name, email\"); FROM(\"tutors\"); WHERE(\"tutor_id=\" + tutorId); &#125; &#125; .toString(); &#125;&#125; SQL 工具类会处理以合适的空格前缀和后缀来构造 SQL 语句。动态 SQL provider 方法可以接收以下其中一种参数： 无参数 和映射器 Mapper 接口的方法同类型的参数 java.util.Map如果 SQL 语句的准备不取决于输入参数，你可以使用不带参数的 SQL Provider 方法。 1234567891011public String findTutorByIdSql()&#123; return new SQL() &#123; &#123; SELECT(\"tutor_id as tutorId, name, email\"); FROM(\"tutors\"); WHERE(\"tutor_id = #&#123;tutorId&#125;\"); &#125; &#125; .toString();&#125; 这里我们没有使用输入参数构造 SQL 语句，所以它可以是一个无参方法。如果映射器 Mapper 接口方法只有一个参数，那么可以定义 SQL Provider 方法，它接受一个与 Mapper 接口方法相同类型的参数。例如映射器 Mapper 接口有如下定义：1Tutor findTutorById(int tutorId); 这里 findTutorById(int)方法只有一个 int 类型的参数。我们可以定义 findTutorByIdSql(int)方法作为 SQLprovider 方法。1234567891011public String findTutorByIdSql(final int tutorId)&#123; return new SQL() &#123; &#123; SELECT(\"tutor_id as tutorId, name, email\"); FROM(\"tutors\"); WHERE(\"tutor_id=\" + tutorId); &#125; &#125; .toString();&#125; 如果映射器 Mapper 接口有多个输入参数，我们可以使用参数类型为 java.util.Map 的方法作为 SQLprovider 方法。然后映射器 Mapper 接口方法所有的输入参数将会被放到 map 中，以 param1,param2 等等作为 key，将输入参数按序作为 value。 你也可以使用 0，1，2 等作为 key 值来取的输入参数。 12345678910111213141516171819@SelectProvider(type = TutorDynaSqlProvider.class,method = \"findTutorByNameAndEmailSql\")Tutor findTutorByNameAndEmail(String name, String email);public String findTutorByNameAndEmailSql(Map&lt;String, Object&gt; map)&#123; String name = (String) map.get(\"param1\"); String email = (String) map.get(\"param2\"); //you can also get those values using 0,1 keys //String name = (String) map.get(\"0\"); //String email = (String) map.get(\"1\"); return new SQL() &#123; &#123; SELECT(\"tutor_id as tutorId, name, email\"); FROM(\"tutors\"); WHERE(\"name=#&#123;name&#125; AND email=#&#123;email&#125;\"); &#125; &#125; .toString();&#125; SQL 工具类也提供了其他的方法来表示 JOINS，ORDER_BY，GROUP_BY 等等。让我们看一个使用 LEFT_OUTER_JOIN 的例子：123456789101112131415161718192021222324252627public class TutorDynaSqlProvider&#123; public String selectTutorById() &#123; return new SQL() &#123; &#123; SELECT(\"t.tutor_id, t.name as tutor_name, email\"); SELECT(\"a.addr_id, street, city, state, zip, country\"); SELECT(\"course_id, c.name as course_name, description, start_date, end_date\"); FROM(\"TUTORS t\"); LEFT_OUTER_JOIN(\"addresses a on t.addr_id=a.addr_id\"); LEFT_OUTER_JOIN(\"courses c on t.tutor_id=c.tutor_id\"); WHERE(\"t.TUTOR_ID = #&#123;id&#125;\"); &#125; &#125; .toString(); &#125;&#125;public interface TutorMapper&#123; @SelectProvider(type = TutorDynaSqlProvider.class, method = \"selectTutorById\") @ResultMap(\"com.mybatis3.mappers.TutorMapper.TutorResult\") Tutor selectTutorById(int tutorId);&#125; 由于没有支持使用内嵌结果 ResultMap 的一对多关联映射的注解支持，我们可以使用基于 XML 的配置，然后与@ResultMap 映射。 123456789101112131415161718192021222324&lt;mapper namespace=\"com.mybatis3.mappers.TutorMapper\"&gt; &lt;resultMap type=\"Address\" id=\"AddressResult\"&gt; &lt;id property=\"id\" column=\"addr_id\" /&gt; &lt;result property=\"street\" column=\"street\" /&gt; &lt;result property=\"city\" column=\"city\" /&gt; &lt;result property=\"state\" column=\"state\" /&gt; &lt;result property=\"zip\" column=\"zip\" /&gt; &lt;result property=\"country\" column=\"country\" /&gt; &lt;/resultMap&gt; &lt;resultMap type=\"Course\" id=\"CourseResult\"&gt; &lt;id column=\"course_id\" property=\"id\" /&gt; &lt;result column=\"course_name\" property=\"name\" /&gt; &lt;result column=\"description\" property=\"description\" /&gt; &lt;result column=\"start_date\" property=\"startDate\" /&gt; &lt;result column=\"end_date\" property=\"endDate\" /&gt; &lt;/resultMap&gt; &lt;resultMap type=\"Tutor\" id=\"TutorResult\"&gt; &lt;id column=\"tutor_id\" property=\"id\" /&gt; &lt;result column=\"tutor_name\" property=\"name\" /&gt; &lt;result column=\"email\" property=\"email\" /&gt; &lt;association property=\"address\" resultMap=\"AddressResult\" /&gt; &lt;collection property=\"courses\" resultMap=\"CourseResult\"&gt;&lt;/collection&gt; &lt;/resultMap&gt;&lt;/mapper&gt; 使用了动态的 SQL provider，我们可以取得讲师及其地址和课程明细。 @InsertProvider我们可以使用@InsertProvider 注解创建动态的 INSERT 语句，如下所示：123456789101112131415161718192021222324252627public class TutorDynaSqlProvider&#123; public String insertTutor(final Tutor tutor) &#123; return new SQL() &#123; &#123; INSERT_INTO(\"TUTORS\"); if (tutor.getName() != null) &#123; VALUES(\"NAME\", \"#&#123;name&#125;\"); &#125; if (tutor.getEmail() != null) &#123; VALUES(\"EMAIL\", \"#&#123;email&#125;\"); &#125; &#125; &#125; .toString(); &#125;&#125;public interface TutorMapper&#123;@InsertProvider(type = TutorDynaSqlProvider.class,method = \"insertTutor\")@Options(useGeneratedKeys = true, keyProperty = \"tutorId\")int insertTutor(Tutor tutor);&#125; @UpdateProvider我们可以通过@UpdateProvider 注解创建 UPDATE 语句，如下所示：12345678910111213141516171819202122232425262728public class TutorDynaSqlProvider&#123;public String updateTutor(final Tutor tutor)&#123;return new SQL()&#123;&#123;UPDATE(\"TUTORS\");if (tutor.getName() != null)&#123;SET(\"NAME = #&#123;name&#125;\");&#125;if (tutor.getEmail() != null)&#123;SET(\"EMAIL = #&#123;email&#125;\");&#125;WHERE(\"TUTOR_ID = #&#123;tutorId&#125;\");&#125;&#125; .toString();&#125;&#125;public interface TutorMapper &#123; @UpdateProvider(type = TutorDynaSqlProvider.class, method = \"updateTutor\") int updateTutor(Tutor tutor);&#125; @DeleteProvider我们可以使用@DeleteProvider 注解创建动态地 DELETE 语句,如下所示：1234567891011121314151617181920public class TutorDynaSqlProvider&#123; public String deleteTutor(int tutorId) &#123; return new SQL() &#123; &#123; DELETE_FROM(\"TUTORS\"); WHERE(\"TUTOR_ID = #&#123;tutorId&#125;\"); &#125; &#125; .toString(); &#125;&#125;public interface TutorMapper&#123; @DeleteProvider(type = TutorDynaSqlProvider.class, method = \"deleteTutor\") int deleteTutor(int tutorId);&#125; 与Spring集成MyBatis-Spring 是 MyBatis 框架的子模块，用来提供与当前流行的依赖注入框架 Spring 的无缝集成。Spring 框 架 是 一 个 基 于 依 赖 注 入 （ Dependency Injection ） 和 面 向 切 面 编 程 (Aspect Oriented Programming,AOP)的 Java 框架，鼓励使用基于 POJO 的编程模型。另外，Spring 提供了声明式和编程式的事务管理能力，可以很大程度上简化应用程序的数据访问层（data access layer）的实现。 在本章中，我们将看到在基于 Spring的应用程序中使用 MyBatis 并且使用 Spring 的基于注解的事务管理机制。本章将包含以下话题： 在 Spring 应用程序中配置 MyBatis 安装 配置 MyBatis Beans 使用 SqlSession 使用映射器 使用 Spring 进行事务管理 在 Spring 应用程序中配置 MyBatis本节将讨论如何在基于 Spring 的应用程序中安装和配置 MyBatis 安装如果你正在使用 Maven 构建工具，你可以配置 MyBatis 的 spring 依赖如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;3.1.3.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;3.1.3.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;3.1.3.RELEASE&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib-nodep&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-dbcp&lt;/groupId&gt; &lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 如果你没有使用 Maven，你可以从 http://code.google.com/p/mybatis/ 上下载 mybatis-spring-1.2.0-boundle.zip。 将其加入，将 mybatis-1.2.0.jar 包添加到 classpath 中。你可以从 http://www.springsource.org/download/community/ 上下载 Spring 框架包 spring-framework-3.1.3.RELEASE.zip。 将其内所有 jar 包添加到 classpath 中。如果你只使用 MyBatis 而没有使用 Spring，在每一个方法中，我们需要手动创建 SqlSessionFactory 对象，并且从 SqlSessionFactory 对象中创建 SqlSession。 而且我们还要负责提交或者回滚事务、 关闭 SqlSession 对象。通过使用 MyBatis-Spring 模块，我们可以在 Spring 的应用上下文 ApplicationContext 中配置 MyBatisBeans,Spring 会负责实例化 SqlSessionFactory 对象以及创建 SqlSession 对象，并将其注入到 DAO 或者 Service类中。 并且，你可以使用 Spring 的基于注解的事务管理功能，不用自己在数据访问层中书写事务处理代码了。 配置 MyBatis Beans为了让 Spring 来实例化 MyBatis 组件如 SqlSessionFactory、 SqlSession、以及映射器 Mapper 对象，我们需要在 Spring 的 bean 配置文件中配置它们，假设在 applicationContext.xml 中，配配置如下：12345678910111213141516171819&lt;beans&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource. DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/elearning\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"admin\" /&gt; &lt;/bean&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"typeAliases\" value=\"com.mybatis3.domain.Student, com.mybatis3.domain.Tutor\" /&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.mybatis3.domain\" /&gt; &lt;property name=\"typeHandlers\" value=\"com.mybatis3.typehandlers.PhoneTypeHandler\" /&gt; &lt;property name=\"typeHandlersPackage\" value=\"com.mybatis3.typehandlers\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:com/mybatis3/**/*.xml\" /&gt; &lt;property name=\"configLocation\" value=\"WEB-INF/mybatisconfig.xml\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 使用上述的 bean 定义，Spring 会使用如下配置属性创建一个 SqlSessionFactory 对象： dataSource:它引用了 dataSource bean typeAliases:它指定了一系列的完全限定名的类名列表，用逗号隔开，这些别名将通过默认的别名规则创建（将首字母小写的非无完全限定类名作为别名）。 typeAliasesPackage:它指定了一系列包名列表，用逗号隔开，包内含有需要创建别名的 JavaBeans。 typeHandlers:它指定了一系列的类型处理器类的完全限定名的类名列表，用逗号隔开。 typeHandlersPackage: 它指定了一系列包名列表，用逗号隔开，包内含有需要被注册的类型处理器类。 mapperLocations:它指定了 SQL 映射器 Mapper XML 配置文件的位置 configLocation:它指定了 MyBatisSqlSessionFactory 配置文件所在的位置。 使用 SqlSession一旦 SqlSessionFactory bean 被配置，我们需要配置 SqlSessionTemplate bean，SqlSessionTemplate bean是一个线程安全的 Spring bean，我们可以从中获取到线程安全的 SqlSession 对象。由于 SqlSessionTemplate 提供线程安全的 SqlSession 对象，你可以在多个 Spring bean 实体对象中共享 SqlSessionTemplate 对象。 从概念上看，SqlSessionTemplate 和 Spring 的 DAO 模块中的 JdbcTemplate 非常相似。123&lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt; 现在我肯可以将 SqlSession bean 实体对象注射到任意的 Spring bean 实体中，然后使用 SqlSession 对象调用SQL 映射语句。123456789101112131415public class StudentDaoImpl implements StudentDao&#123; private SqlSession sqlSession; public void setSqlSession(SqlSession session) &#123; his.sqlSession = session; &#125; public void createStudent(Student student) &#123; StudentMapper mapper = this.sqlSession.getMapper(StudentMapper.class); mapper.insertStudent(student); &#125;&#125; 如果你正在使用基于 XML 来配置 Spring beans,你可以将 SqlSession bean 实体对象注射到 StudenDaoImplbean 实体对象中，如下：123&lt;bean id=\"studentDao\" class=\"com.mybatis3.dao.StudentDaoImpl\"&gt; &lt;property name=\"sqlSession\" ref=\"sqlSession\" /&gt;&lt;/bean&gt; 如果你使用基于注解的方式配置 Spring beans，你如下将 SqlSession bean 实体对象注入到 StudentDaoImpl bean 实体对象中： 12345678910111213141516@Repositorypublic class StudentDaoImpl implements StudentDao&#123; private SqlSession sqlSession; @Autowired public void setSqlSession(SqlSession session) &#123; this.sqlSession = session; &#125; public void createStudent(Student student) &#123; StudentMapper mapper = this.sqlSession.getMapper(StudentMapper.class); mapper.insertStudent(student); &#125;&#125; 还有另外一种注入 Sqlsession 对象的方法，即，通过拓展继承 SqlSessionDaoSupport。 这种方式让我们可以在执行映射语句时，加入任何自定义的逻辑。 123456789101112public class StudentMapperImpl extends SqlSessionDaoSupport implementsStudentMapper&#123; public void createStudent(Student student) &#123; StudentMapper mapper = getSqlSession().getMapper(StudentMapper.class); mapper.insertAddress(student.getAddress()); //Custom logic mapper.insertStudent(student); &#125;&#125; 123&lt;bean id=\"studentMapper\" class=\"com.mybatis3.dao.StudentMapperImpl\"&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt; 在以上的这些方式中，我们注入了 SqlSession 对象，获取 Mapper 实例，然后执行映射语句。这里 Spring 会为我们提供一个线程安全的 SqlSession 对象，以及当方法结束后关闭 SqlSession 对象。然而，MyBatis-Spring 模块提供了更好的方式，我们可以不通过 SqlSession 获取映射器 Mapper，直接注射 Sql映射器 Mapper bean。我们下节将讨论它。 使用映射器我们可以使用 MapperFactoryBean 将映射器 Mapper 接口配置成 Spring bean 实体。 如下所示：123456public interface StudentMapper&#123; @Select(\"select stud_id as studId, name, email, phone from students where stud_id=#&#123;id&#125;\") Student findStudentById(Integer id);&#125; 1234&lt;bean id=\"studentMapper\" class=\"org.mybatis.spring.mapper. MapperFactoryBean\"&gt; &lt;property name=\"mapperInterface\" value=\"com.mybatis3.mappers. StudentMapper\" /&gt; &lt;property name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\" /&gt;&lt;/bean&gt; 现在 StudentMapper bean 实体对象可以被注入到任意的 Spring bean 实体对象中，并调用映射语句方法，如下所示： 123456789101112public class StudentService&#123; private StudentMapper studentMapper; public void setStudentMapper (StudentMapperstudentMapper) &#123; this. studentMapper = studentMapper; &#125; public void createStudent(Student student) &#123; this.studentMapper.insertStudent(student); &#125;&#125; 123&lt;bean id=\"studentService\" class=\"com.mybatis3.services. StudentService\"&gt; &lt;property name=\"studentMapper\" ref=\"studentMapper\" /&gt;&lt;/bean&gt; 分别配置每一个映射器 Mapper 接口是一个非常单调的过程。我们可以使用 MapperScannerConfigurer 来扫描包（package）中的映射器 Mapper 接口，并自动地注册。 123&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.mybatis3.mappers\" /&gt;&lt;/bean&gt; 如果映射器 Mapper 接口在不同的包(package)中，你可以为 basePackage 属性指定一个以逗号分隔的包名列表。MyBatis-Spring-1.2.0 介绍了两种新的扫描映射器 Mapper 接口的方法： 使用mybatis:scan/元素 使用@MapperScan 注解（需 Spring3.1+版本） &lt;mybatis:scan /&gt;&lt;mybatis:scan&gt;元素将在特定的以逗号分隔的包名列表中搜索映射器 Mapper 接口。 使用这个新的 MyBatisSpring 名空间你需要添加以下的 schema 声明：12345678910&lt;beans xmlns=\"http://www.springframework.org/schema/beans\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xmlns:mybatis=\"http://mybatis.org/schema/mybatis-spring\"xsi:schemaLocation=\"http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://mybatis.org/schema/mybatis-springhttp://mybatis.org/schema/mybatis-spring.xsd\"&gt; &lt;mybatis:scan base-package=\"com.mybatis3.mappers\" /&gt;&lt;/beans&gt; mybatis:scan元素提供了下列的属性来自定义扫描过程： annotation: 扫描器将注册所有的在 base-package 包内并且匹配指定注解的映射器 Mapper 接口。 factory-ref: 当 Spring 上 下 文 中 有 多 个 SqlSessionFactory 实 例 时 ， 需 要 指 定 某 一 特 定 的SqlSessionFactory 来创建映射器 Mapper 接口。正常情况下，只有应用程序中有一个以上的数据源才会使用。 marker-interface: 扫描器将注册在 base-package 包中的并且继承了特定的接口类的映射器 Mapper 接口 template-ref: 当 Spring 上下文中有多个 SqlSessionTemplate 实例时，需要指定某一特定的SqlSessionTemplate 来创建映射器 Mapper 接口。 正常情况下，只有应用程序中有一个以上的数据源才会使用。 name-generator:BeannameGenerator 类的完全限定类名，用来命名检测到的组件。 MapperScanSpring 框架 3.x+版本支持使用@Configuration 和@Bean 注解来提供基于 Java 的配置。如果你倾向于使用基于Java 的配置，你可以使用@MapperScan 注解来扫描映射器 Mapper 接口。 @MapperScan 和mybatis:scan/工作方式相同，并且也提供了对应的自定义选项。 12345678910111213141516171819@Configuration@MapperScan(\"com.mybatis3.mappers\")public class AppConfig&#123; @Bean public DataSource dataSource() &#123; return new PooledDataSource(\"com.mysql.jdbc.Driver\", \"jdbc:mysql://localhost:3306/elearning\", \"root\", \"admin\"); &#125; @Bean public SqlSessionFactory sqlSessionFactory() throws Exception &#123; SqlSessionFactoryBeansessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource()); return sessionFactory.getObject(); &#125;&#125; @MapperScan 注解有以下属性供自定义扫描过程使用: annotationClass: 扫描器将注册所有的在 base-package 包内并且匹配指定注解的映射器 Mapper 接口。 markerInterface: 扫描器将注册在 base-package 包中的并且继承了特定的接口类的映射器 Mapper 接口 sqlSessionFactoryRef:当 Spring 上 下 文 中 有 一 个以 上 的 SqlSesssionFactory 时 ， 用 来 指 定 特 定SqlSessionFactory sqlSessionTemplateRef: 当 Spring 上下文中有一个以上的 sqlSessionTemplate 时，用来指定特定sqlSessionTemplate nameGenerator:BeanNameGenerator 类用来命名在 Spring 容器内检测到的组件。 basePackageClasses:basePackages()的类型安全的替代品。 包内的每一个类都会被扫描。 basePackages:扫描器扫描的基包，扫描器会扫描内部的 Mapper 接口。 注意包内的至少有一个方法声明的才会被注册。 具体类将会被忽略。 与注入 Sqlsession 相比，更推荐使用注入 Mapper，因为它摆脱了对MyBatis API 的依赖。 使用Spring进行事务管理只使用 MyBatis，你需要写事务控制相关代码，如提交或者回退数据库操作。123456789101112131415161718192021public Student createStudent(Student student)&#123; SqlSession sqlSession = MyBatisUtil.getSqlSessionFactory().openSession(); try &#123; StudentMapper mapper = sqlSession.getMapper(StudentMapper.class); mapper.insertAddress(student.getAddress()); mapper.insertStudent(student); sqlSession.commit(); return student; &#125; catch (Exception e) &#123; sqlSession.rollback(); throw new RuntimeException(e); &#125; finally &#123; sqlSession.close(); &#125;&#125; 我们可以使用 Spring 的基于注解的事务处理机制来避免书写上述的每个方法中控制事务的冗余代码。为了能使用 Spring 的事务管理功能，我们需要在 Spring 应用上下文中配置 TransactionManager bean 实体对象： 1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc. datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt;&lt;/bean&gt; 事务管理器引用的 dataSource 和 SqlSessionFactory bean 使用的 dataSource 相同。在 Spring 中使用基于注解的事务管理特性，如下：1&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 现在你可以在 Spring service bean 上使用@Transactional 注解，表示在此 service 中的每一个方法都应该在一个事务中运行。 如果方法成功运行完毕，Spring 会提交操作。如果有运行期异常发生，则会执行回滚操作。 另外，Spring 会将 MyBatis 的异常转换成合适的 DataAccessExceptions，这样会为特定错误上提供额外的信息。1234567891011121314151617Service@Transactionalpublic class StudentService&#123; @Autowired private StudentMapper studentMapper; public Student createStudent(Student student) &#123; studentMapper.insertAddress(student.getAddress()); if(student.getName().equalsIgnoreCase(\"\")) &#123; throw new RuntimeException(\"Student name should not be empty.\"); &#125; studentMapper.insertStudent(student); return student; &#125;&#125; 下面是一个 Spring 的 applicationContext.xml 完成配置：1234567891011121314151617181920212223242526272829303132&lt;beans&gt; &lt;context:annotation-config /&gt; &lt;context:component-scan base-package=\"com.mybatis3\" /&gt; &lt;context:property-placeholder location=\"classpath:application.properties\" /&gt; &lt;tx:annotation-driven transaction-manager=\"transactionManager\" /&gt; &lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;/bean&gt; &lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt; &lt;property name=\"basePackage\" value=\"com.mybatis3.mappers\" /&gt; &lt;/bean&gt; &lt;bean id=\"sqlSession\" class=\"org.mybatis.spring.SqlSessionTemplate\"&gt; &lt;constructor-arg index=\"0\" ref=\"sqlSessionFactory\" /&gt; &lt;/bean&gt; &lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\" /&gt; &lt;property name=\"typeAliases\" value=\"com.mybatis3.domain.Student,com.mybatis3.domain.Tutor\" /&gt; &lt;property name=\"typeAliasesPackage\" value=\"com.mybatis3.domain\" /&gt; &lt;property name=\"typeHandlers\" value=\"com.mybatis3.typehandlers.PhoneTypeHandler\" /&gt; &lt;property name=\"typeHandlersPackage\" value=\"com.mybatis3.typehandlers\" /&gt; &lt;property name=\"mapperLocations\" value=\"classpath*:com/mybatis3/**/*.xml\" /&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driverClassName&#125;\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 现在让我们写一个独立的测试客户端来测试 StudentService，如下:12345678910111213141516171819202122232425262728293031323334353637@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = \"classpath:applicationContext.xml\")public class StudentServiceTest&#123;@Autowiredprivate StudentService studentService;@Testpublic void testCreateStudent()&#123;Address address = new Address(0, \"Quaker RidgeRd.\", \"Bethel\", \"Brooklyn\", \"06801\", \"USA\");Student stud = new Student();long ts = System.currentTimeMillis();stud.setName(\"stud_\" + ts);stud.setEmail(\"stud_\" + ts + \"@gmail.com\");stud.setAddress(address);Student student = studentService.createStudent(stud);assertNotNull(student);assertEquals(\"stud_\" + ts, student.getName());assertEquals(\"stud_\" + ts + \"@gmail.com\", student.getEmail());System.err.println(\"CreatedStudent: \" + student);&#125;@Test(expected = DataAccessException.class)public void testCreateStudentForException()&#123;Address address = new Address(0, \"Quaker RidgeRd.\", \"Bethel\", \"Brooklyn\", \"06801\", \"USA\");Student stud = new Student();long ts = System.currentTimeMillis();stud.setName(\"Timothy\");stud.setEmail(\"stud_\" + ts + \"@gmail.com\");stud.setAddress(address);studentService.createStudent(stud);fail(\"You should not reach here\");&#125;&#125; 这里在 testCreateStudent()方法中，我们为 Address 和 Student 赋上了合适的数据，所以 Address 和 Student会被分别插入到表 ADDRESSES 和 STUDENTS 中。在 testCreateStudentForException()方法我们设置了名字为Timothy，该名称在数据库中已经存在了，所以当你尝试将此 student 记录插入到数据库中，MySQL 会抛出一个 UNIQUEKEY 冲突的异常，Spring 会将此异常转换成 DataAccessException 异常，并且将插入 ADDRESSES 表中的数据回滚（rollback）掉。 总结在本章中我们学习了怎样将 MyBatis 与 Spring 框架集成。我们还学习了怎样安装 Spring 类库并且在 Spring 的应用上下文 ApplicationContext 上注册 MyBatis bean 实体对象。我们还看到怎样配置和注入 SqlSession 和 Mapper bean 实体对象以及调用映射语句。我们还学习了利用 Spring 基于注解的事务处理机制来使用 MyBatis。你已经读完本书，祝贺你！现在，你应该知道怎样高效地使用 MyBatis 与数据库工作。 你学会了怎样发挥你的 Java 和 SQL 技巧的优势使 MyBatis 更富有成效。你知道了怎样以更清晰的方式使用 MyBatis 写出数据持久化代码，不用管被 MyBatis 框架处理的所有底层细节。 另外，你学会了怎样在最流行的依赖注入框架-Spring 中使用 MyBatis。MyBatis 框架非常易于使用，但它提供了强大的特性，因此它对于基于 Java 的项目而言，是一个非常好的数据库持久化解决方案。 MyBatis 也提供了一些工具如 MyBatis Generator(http://www.mybatis.org/generator/)，可以被用来从已经存在的数据库 schema 中，产生持久化代码如数据库实体（database entities）,映射器 Mapper 接口，MapperXML 配置文件，使 MyBatis 入门非常方便。 另外，MyBatis 还有它的姊妹项目如 MyBatis.NET 和 MyBatisScala，分别为.NET 和 Scala 编程语言提供了一样强大的特性。MyBatis 随着每一个版本的发布，增加了一些特性，正变得越来越好。 想了解更多的新特性，你可以访问 MyBatis官方网站 https://code.google.com/p/mybatis/ .订阅 MyBatis 的使用者邮件列表是一个不错的想法。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://skiyubon.github.io/categories/JavaWeb/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"https://skiyubon.github.io/tags/MyBatis/"}]},{"title":"SpringMVC详解","slug":"SpringMVC详解","date":"2017-04-12T11:50:14.000Z","updated":"2017-04-13T02:10:47.290Z","comments":true,"path":"2017/04/12/SpringMVC详解/","link":"","permalink":"https://skiyubon.github.io/2017/04/12/SpringMVC详解/","excerpt":"","text":"SpringMVC 框架结构 SpringMVC 框架的默认的实现者 HTTP请求地址映射通过URL限定：URL表达式@RequestMapping不但支持标准的URL，还支持Ant风格（即？、*、和**的字符）的和带{XXX}占位符的URL。以下URL都是合法的： - /user/*/createUser 匹配/user/aaa/createUser、 /user/bbb/createUser等URL。 - /user/**/createUser 匹配/user/createUser、 /user/aaa/bbb/createUser等URL。 - /user/createUser?? 匹配/user/createUseraa、 /user/createUserbb等URL。 - /user/{userId} 匹配user/123、 user/abc等URL。 - /user/**/{userId} 匹配user/aaa/bbb/123、 user/aaa/456等URL。 - company/{companyId}/user/{userId}/detail 匹配company/123/user/456/detail等的URL。 通过URL限定：绑定{XXX}中的值1234567@RequestMapping(\"/&#123;userId&#125;\")public ModelAndView showDetail(@PathVariable(\"userId\") String userId)&#123; ModelAndView mav = new ModelAndView(); //URL中的&#123;XXX&#125;占位符通过@PathVariable(\"XXX\")绑定到操作方法的入参中。 mav.setViewName(\"user/showDetail\"); mav.addObject(\"user\", userService.getUserById(userId)); return mav;&#125; 123456789@Controller@RequestMapping(\"/owners/&#123;ownerId&#125;\")public class RelativePathUriTemplateController &#123; @RequestMapping(\"/pets/&#123;petId&#125;\") public void findPet(@PathVariable String ownerId, //如果@PathVariable不指定参数名，只有在编译时打开debug开关（java -debug=no）时才可行！！不建议这种方式。 @PathVariable String petId, Model model) &#123; … &#125;&#125; 通过请求方法限定：请求方法请求方法，在HTTP中这被叫做动词（ verb），除了两个大家熟知的（ GET和POST）之外，标准方法集合中还包含PUT、 DELETE、 HEAD和OPTIONS。这些方法的含义连同行为许诺都一起定义在HTTP规范之中。一般浏览器只支持GET和POST方法。 12345678910111213141516171 GET 使用GET方法检索一个表述（ representation） ——也就是对资源的描述。多次执行同一GET请求，不会对系统造成影响， GET方法具有幂等性[指多个相同请求返回相同的结果]。 GET请求可以充分使用客户端的缓存。2 POST POST方法，通常表示“创建一个新资源”，但它既不安全也不具有幂等性（多次操作会产生多个新资源）。3 DELETE DELETE，表示删除一个资源，你也可以一遍又一遍地操作它，直到得出结果：删除不存在的东西没有任何问题4 PUT 幂等性同样适用于PUT（基本的含义是“更新资源数据，如果资源不存在的话，则根据此URI创建一个新的资源”）示例1：@RequestMapping(value=“/delete”)public String test1(@RequestParam(\"userId\") String userId)&#123;return \"user/test1\";&#125;-- 所有URL为&lt;controllerURI&gt;/delete的请求由test1处理(任何请求方法)示例2：@RequestMapping(value=\"/delete\",method=RequestMethod.POST)public String test1(@RequestParam(\"userId\") String userId)&#123;return \"user/test1\";&#125;-- 所有URL为&lt;controllerURI&gt;/delete 且请求方法为POST 的请求由test1处理 通过请求方法限定:模拟请求方法通过在web.xml中配置一个org.springframework.web.filter.HiddenHttpMethodFilter通过POST请求的_method参数指定请求方法， HiddenHttpMethodFilter动态更改HTTP头信息。 通过请求/请求头参数限定:示例 通过请求参数限定 1234@RequestMapping(value=\"/delete\", params=\"userId\")public String test1(@RequestParam(\"userId\") String userId)&#123;...&#125; 通过请求头参数限定 1234@RequestMapping(value=\"/show\",headers=\"content-type=text/*\")②public String test2(@RequestParam(\"userId\") String userId)&#123;...&#125; 通过请求/请求头参数限定:更多params和headers分别通过请求参数及报文头属性进行映射，它们支持简单的表达式，下面以params表达式为例说明， headers可以参照params进行理解之。 “param1”： 表示请求必须包含名为param1的请求参数。 “!param1”： 表示请求不能包含名为param1的请求参数。 “param1!=value1”： 表示请求包含名为param1的请求参数，但其值不能为value1。 {“param1=value1”,”param2”}： 请求必须包含名为param1和param2的两个请求参数，且param1参数的值必须为value1。 HTTP请求数据的绑定通过注解绑定：示意图 通过注解绑定：示例123456@RequestMapping(value=\"/handle1\")public String handle1(@RequestParam(\"userName\") String userName, @RequestParam(\"password\") String password, @RequestParam(\"realName\") String realName)&#123; ...&#125; 12345@RequestMapping(value=\"/handle2\")public String handle2(@CookieValue(\"JSESSIONID\") String sessionId, @RequestHeader(\"Accept-Language\") String accpetLanguage)&#123; ...&#125; 过注解绑定:小心抛出异常@RequestParam有以下三个参数。 value：参数名。 required：是否必需，默认为true，表示请求中必须包含对应的参数名，如果不存在将抛出异常。 defaultValue：默认参数名，设置该参数时，自动将required设为false。极少情况需要使用该参数，也不推荐使用该参数。 1234@RequestMapping(value=\"/handle1\")public String handle1(@RequestParam(\"userName\") String userName,)&#123;...&#125; 上面的处理方法 ，如果HTTP请求不包含“ userName”参数时，将产生异常！！因此，如果不能保证存在”userName”的参数，必须使用：@RequestParam(value = “userName”, required = false) 使用命令/表单对象绑定所谓命令/表单对象并不需要实现任何接口，仅是一个拥有若干属性的POJO。Spring MVC按：“ HTTP请求参数名 = 命令/表单对象的属性名”的规则，自动绑定请求数据，支持“级联属性名”，自动进行基本类型数据转换。123456789@RequestMapping(value = \"/handle14\")public String handle14(User user) &#123;…&#125; userName=xxx&amp;password=yyy -----&gt;&gt;&gt;&gt;&gt;class User&#123; private String userName; private String password; &#125; 使用Servlet API对象作为入参在Spring MVC中，控制器类可以不依赖任何Servlet API对象，但是Spring MVC并不阻止我们使用Servlet API的类作为处理方法的入参。值得注意的是， 如果处理方法自行使用HttpServletResponse返回响应，则处理方法的返回值设置成void即可。12345@RequestMapping(value = \"/handle21\")public void handle21(HttpServletRequest request,HttpServletResponse response) &#123; String userName = WebUtils.findParameterValue(request, \"userName\"); response.addCookie(new Cookie(\"userName\", userName));&#125; 1234public String handle23(HttpSession session) &#123; session.setAttribute(\"sessionId\", 1234); return \"success\";&#125; 12345public String handle24(HttpServletRequest request, @RequestParam(\"userName\")String userName) &#123; … return \"success\";&#125; 使用Spring的Servlet API代理类Spring MVC在org.springframework.web.context.request包中定义了若干个可代理Servlet原生API类的接口，如WebRequest和NativeWebRequest，它们也允许作为处理类的入参，通过这些代理类可访问请求对象的任何信息。12345@RequestMapping(value = \"/handle25\")public String handle25(WebRequest request) &#123; String userName = request.getParameter(\"userName\"); return \"success\";&#125; 使用IO对象作为入参Spring MVC允许控制器的处理方法使用java.io.InputStream/java.io.Reader及java.io.OutputStream/java.io.Writer作为方法的入参 12345@RequestMapping(value = \"/handle31\")public void handle31(OutputStream os) throws IOException&#123; Resource res = new ClassPathResource(\"/image.jpg\");//读取类路径下的图片文件 FileCopyUtils.copy(res.getInputStream(), os);//将图片写到输出流中&#125; 其他类型的参数控制器处理方法的入参除支持以上类型的参数以外，还支持java.util.Locale、java.security.Principal，可以通过Servlet的HttpServletRequest 的getLocale()及getUserPrincipal()得到相应的值。如果处理方法的入参类型为Locale或Principal， Spring MVC自动从请求对象中获取相应的对象并传递给处理方法的入参。 1234@RequestMapping(value = \"/handle32\")public void handle31(Locale locale) throws IOException&#123;...&#125; 使用@RequestBody/@ResponseBody将HttpServletRequest的getInputStream()内容绑定到入参，将处理方法返回值写入到HttpServletResponse的getOutputStream()中。12345@RequestMapping(value = \"/handle41\")public String handle41(@RequestBody String requestBody ) &#123; System.out.println(requestBody); return \"success\";&#125; 12345678@ResponseBody@RequestMapping(value = \"/handle42/&#123;imageId&#125;\")public byte[] handle42(@PathVariable(\"imageId\") String imageId) throws IOException &#123; System.out.println(\"load image of \"+imageId); Resource res = new ClassPathResource(\"/image.jpg\"); byte[] fileData =FileCopyUtils.copyToByteArray(res.getInputStream()); return fileData;&#125; 优点：处理方法签名灵活不受限 缺点：只能访问报文体，不能访问报文头 使用HttpEntity/ResponseEntity123456@RequestMapping(value = \"/handle43\")public String handle43(HttpEntity&lt;String&gt; httpEntity)&#123; long contentLen = httpEntity.getHeaders().getContentLength(); System.out.println(httpEntity.getBody()); return \"success\";&#125; 12345678910@RequestMapping(params = \"method=login\")public ResponseEntity&lt;String&gt; doFirst()&#123; HttpHeaders headers = new HttpHeaders(); MediaType mt=new MediaType(\"text\",\"html\",Charset.forName(“UTF-8\")); headers.setContentType(mt); ResponseEntity&lt;String&gt; re=null; String return = new String(\"test\"); re=new ResponseEntity&lt;String&gt;(return,headers, HttpStatus.OK); return re;&#125; 优点：处理方法签名受限 缺点：不但可以访问报文体，还能访问报文头 使用HttpEntity/ResponseEntity123456@RequestMapping(value = \"/handle51\")public ResponseEntity&lt;User&gt; handle51(HttpEntity&lt;User&gt; requestEntity)&#123; User user = requestEntity.getBody(); user.setUserId(\"1000\"); return new ResponseEntity&lt;User&gt;(user,HttpStatus.OK);&#125; 对于服务端的处理方法而言，除使用@RequestBody/@ResponseBody或HttpEntity /ResponseEntity进行方法签名外，不需要进行任何额外的处理，借由Spring MVC中装配的HttpMessageConverter，它即拥有了处理XML及JSON的能力了。 输出XML和JSON 数据转换、格式化、检验数据绑定机理 数据类型转换低版本的Spring 只支持标准的PropertyEditor类型体系，不过PropertyEditor存在以下缺陷： 只能用于字符串和Java对象的转换，不适用于任意两个Java类型之间的转换； 对源对象及目标对象所在的上下文信息（如注解、所在宿主类的结构等）不敏感，在类型转换时不能利用这些上下文信息实施高级转换逻辑。 有鉴于此， Spring 3.0在核心模型中添加了一个通用的类型转换模块，ConversionService是Spring类型转换体系的核心接口。Spring 3.0同时支持PropertyEditor和ConversionService 进行类型转换，在Bean配置、 Spring MVC处理方法入参绑定中使用类型转换体系进行工作。 PropertyEditor依然有效对于简单的类型转换，依然建议使用PropertyEditor。按照PropertyEditor的协议，会自动查找Bean类相同类包是否存在Editor.class，如果存在会使用它作为Bean的编辑器。com.book.core.cache.expired|CacheSpace.java| CacheSpaceEditor.java12345678910&lt;bean id=\"expireManager\"class=\"com.book.core.cache.expire.SimpleCacheLogicExpireManager\"&gt; &lt;property name=\"cacheSpaceList\"&gt; &lt;list&gt; &lt;value&gt;comBookSpace:com/comBook/**&lt;/value&gt; &lt;value&gt;bookSpace:com/book/**:100&lt;/value&gt; &lt;value&gt;companySpace:com/company/**&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 强大的ConversionService由于ConversionService在进行类型转换时，可以使用到Bean所在宿主类的上下文信息（包括类结构，注解信息），所以可以实施更加高级的类型转换，如注解驱动的格式化等功能。1234public class User &#123; @DateTimeFormat(pattern=\"yyyy-MM-dd\") private Date birthday;&#125; 以上User类，通过一个@DateTimeFormat注解，为类型转换提供了一些“额外”的信息，即代表日期的“源字符器”格式是“ yyyy-MM-dd” 基于ConversionService体系，定义自定义的类型转换器定义自定义转换器：StringTOUserConverter注册自定义转换器：123456789&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.baobaotao.domain.StringToUserConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 格式化：带格式字符串内部对象 相互转换 使用支持格式化的转换器123456789&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;&lt;bean id=\"conversionService\"class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.baobaotao.domain.StringToUserConverter\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 值得注解的是， mvc:annotation-driven/标签内部默认创建的ConversionService实例就是一个FormattingConversionServiceFactoryBean，自动支持如下的格式化注解： @NumberFormatter：用于数字类型对象的格式化。 @CurrencyFormatter：用于货币类型对象的格式化。 @PercentFormatter：用于百分数数字类型对象的格式化。 数据校验框架Spring 3.0拥有自己独立的数据校验框架，同时支持JSR 303标准的校验框架。 Spring 的DataBinder在进行数据绑定时，可同时调用校验框架完成数据校验工作。在Spring MVC中，则可直接通过注解驱动的方式进行数据校验。Spring的org.springframework.validation是校验框架所在的包 JSR 303SR 303是Java为Bean数据合法性校验所提供的标准框架，它已经包含在Java EE6.0中。 JSR 303通过在Bean属性上标注类似于@NotNull、 @Max等标准的注解指定校验规则，并通过标准的验证接口对Bean进行验证。你可以通过http://jcp.org/en/jsr/detail?id=303了解JSR 303的详细内容。 数据校验框架mvc:annotation-driven/会默认装配好一个LocalValidatorFactoryBean，通过在处理方法的入参上标注@Valid注解即可让Spring MVC在完成数据绑定后执行数据校验的工作。12345678910111213141516public class User &#123; @Pattern(regexp=\"w&#123;4,30&#125;\") private String userName; @Length(min=2,max=100) private String realName; @Past @DateTimeFormat(pattern=\"yyyy-MM-dd\") private Date birthday; @DecimalMin(value=\"1000.00\") @DecimalMax(value=\"100000.00\") @NumberFormat(pattern=\"#,###.##\") private long salary;&#125; 注意： Spring本身没有提供JSR 303的实现，所以必须将JSR 303的实现者（如Hibernate Validator）的jar文件放到类路径下， Spring将自动加载并装配好JSR 303的实现者。 如何使用注解驱动的校验123456789101112@Controller@RequestMapping(\"/user\") public class UserController &#123; @RequestMapping(value = \"/handle91\") public String handle91(@Valid User user,BindingResult bindingResult)&#123; if(bindingResult.hasErrors())&#123; return \"/user/register3\"; &#125;else&#123; return \"/user/showUser\"; &#125; &#125;&#125; 在已经标注了JSR 303注解的表单/命令对象前标注一个@Valid，Spring MVC框架在将请求数据绑定到该入参对象后，就会调用校验框架根据注解声明的校验规则实施校验。 使用校验功能时，处理方法要如何签名？？Spring MVC是通过对处理方法签名的规约来保存校验结果的：前一个表单/命令对象的校验结果保存在其后的入参中，这个保存校验结果的入参必须是BindingResult或Errors类型，这两个类都位于org.springframework.validation包中。 校验错误信息存放在什么地方？？ Spring MVC将HttpServletRequest对象数据绑定到处理方法的入参对象中（表单/命令对象）； 将绑定错误信息、检验错误信息都保存到隐含模型中； 本次请求的对应隐含模型数据存放到HttpServletRequest的属性列表中，暴露给视图对象。 页面如何显示错误信息12345678910111213141516171819202122232425&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;注册用户&lt;/title&gt;&lt;style&gt;.errorClass&#123;color:red&#125;&lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;form:form modelAttribute=\"user\" action=\"user/handle91.html\"&gt; &lt;form:errors path=\"*\"/&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名： &lt;/td&gt; &lt;td&gt; &lt;form:errors path=\"userName\" cssClass=\"errorClass\"/&gt; &lt;form:input path=\"userName\" /&gt; &lt;/td&gt; &lt;/tr&gt; … &lt;/table&gt; &lt;/form:form&gt; &lt;/body&gt;&lt;/html&gt; 数据模型控制数据模型访问结构 访问数据模型:ModelAndView12345678@RequestMapping(method = RequestMethod.POST)public ModelAndView createUser(User user) &#123; userService.createUser(user); ModelAndView mav = new ModelAndView(); mav.setViewName(\"user/createSuccess\"); mav.addObject(\"user\", user); return mav;&#125; 访问数据模型： @ModelAttribute 使用方式一12345@RequestMapping(value = \"/handle61\")public String handle61(@ModelAttribute(\"user\") User user)&#123; user.setUserId(\"1000\"); return \"/user/createSuccess\";&#125; Spring MVC将HTTP请求数据绑定到user入参中，然后再将user对象添加到数据模型中。 使用方式二 访问数据模型： Map及Modelorg.springframework.ui.Model和java.util.Map:1234567@RequestMapping(value = \"/handle63\") public String handle63(ModelMap modelMap)&#123; modelMap.addAttribute(\"testAttr\",\"value1\"); User user = (User)modelMap.get(\"user\"); user.setUserName(\"tom\"); return \"/user/showUser\";&#125; Spring MVC一旦发现处理方法有Map或Model类型的入参，就会将请求内在的隐含模型对象的引用传给这些入参。 访问数据模型： @SessionAttributes如果希望在多个请求之间共用某个模型属性数据，则可以在控制器类标注一个@SessionAttributes， Spring MVC会将模型中对应的属性暂存到HttpSession中: 一场由@SessionAttributes引发的血案-&gt;org.springframework.web.HttpSessionRequiredException: Session attribute ‘user’ required -not found in session… 对入参标注@ModelAttribute(“xxx”)的处理方法， Spring MVC按如下流程处理（ handle71(@ModelAttribute(“user”) User user)）： 如果隐含模型拥有名为xxx的属性，将其赋给该入参，再用请求消息填充该入参对象直接返回，否则到2步 。 如果xxx是会话属性，即在处理类定义处标注了@SessionAttributes(“xxx”)，则尝试从会话中获取该属性，并将其赋给该入参，然后再用请求消息填充该入参对象。 如果在会话中找不到对应的属性，则抛出HttpSessionRequiredException异常。 否则到 3。 如果隐含模型不存在xxx属性，且xxx也不是会话属性，则创建入参的对象实例，再用请求消息填充该入参 如何避免？ 视图及解析器Spring MVC如何解析视图 视图解析器类型 InternalResourceViewResolver FreeMarkerViewResolver BeanNameViewResolver XmlViewResolver …完成单一解析逻辑的视图解析器：基于协商的视图解析器： ContentNegotiatingViewResolver该解析器是Spring 3.0新增的，它不负责具体的视图解析，而是作为一个中间人的角色根据请求所要求的MIME类型，从上下文中选择一个适合的视图解析器，再将视图解析工作委托其负责 基于协商的视图解析器12345678910111213141516171819202122&lt;bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\"p:order=\"0\" p:defaultContentType=\"text/html\" p:ignoreAcceptHeader=\"true\"p:favorPathExtension=\"false\" p:favorParameter=\"true\" p:parameterName=\"content\"&gt; &lt;property name=\"mediaTypes\"&gt; &lt;map&gt; &lt;entry key=\"html\" value=\"text/html\" /&gt; &lt;entry key=\"xml\" value=\"application/xml\" /&gt; &lt;entry key=\"json\" value=\"application/json\" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=\"defaultViews\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.web.servlet.view.json.MappingJacksonJsonView\" p:renderedAttributes=\"userList\" /&gt; &lt;bean class=\"org.springframework.web.servlet.view.xml.MarshallingView\" p:modelKey=\"userList\" p:marshaller-ref=\"xmlMarshaller\" /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"p:order=\"100\" p:viewClass=\"org.springframework.web.servlet.view.JstlView\"p:prefix=\"/WEB-INF/views/\" p:suffix=\".jsp\" /&gt; 其他静态资源处理Spring MVC 3.0提供的最强大的功能之一！！！1.静态资源处理方式2.静态资源映射 静态资源处理:使REST风格的URL成为实现优雅REST风格的资源URL不希望带.html或.do等后缀，以下是几个优雅的URL。 /blog/tom：用户tom的blog资源。 /forum/java： java论坛板块资源。 /order/4321：订单号为4321的订单资源； 静态资源处理:原理 静态资源处理:如何配置？ 第一步： web.xml让所有请求都由Spring MVC处理 123456789&lt;servlet&gt; &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt; &lt;servletclass&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servletclass&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 第二步： springServlet-servlet.xml 让Web应用服务器处理静态资源1&lt;mvc:default-servlet-handler/&gt; 获取应用服务器的默认Servlet,大多数应用服务器的Servlet的名称都是“ default”，如果默认不是“ default”则使用12&lt;mvc:default-servlet-handlerdefault-servlet-name=“&lt;defaultServletName&gt;\"/&gt; 物理静态资源路径映射逻辑资源路径12&lt;mvc:resources mapping=\"/resources/**\"location=\"/,classpath:/META-INF/publicResources/\"/&gt; 123456789101112&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;静态资源测试页面&lt;/title&gt; &lt;script src=\"&lt;c:url value=\"/resources/js/test.js\"/&gt;\" type=\"text/javascript\"&gt; &lt;/script&gt;&lt;/head&gt; &lt;body&gt; &lt;script&gt;test();&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 允许利用浏览器的缓存且不担心不同步12345&lt;mvc:default-servlet-handler/&gt;&lt;bean id=\"rpe\" class=\"com.baobaotao.web.ResourcePathExposer\"init-method=\"init\"/&gt;&lt;mvc:resources mapping=\"#&#123;rpe.resourceRoot&#125;/**\"location=\"/\" cache-period=\"31536000\"/&gt; 12345678public class ResourcePathExposer implements ServletContextAware &#123;public void init() &#123; String version = \"1.2.1\"; resourceRoot = \"/resources-\" + version; getServletContext().setAttribute(\"resourceRoot\", getServletContext().getContextPath()+resourceRoot); &#125;&#125; 12345678910&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;静态资源测试&lt;/title&gt;&lt;script src=\"$&#123;resourceRoot&#125;/js/test.js\" type=\"text/javascript\"&gt; &lt;/script&gt;&lt;/head&gt;...&lt;/html&gt; 本地化本地化原理一般情况下， Web应用根据客户端浏览器的设置判断客户端的本地化类型，用户可以通过IE菜单： 工具→Internet选项…→语言…在打开的“语言首选项”对话框中选择本地化类型。浏览器中设置的本地化类型会包含在HTML请求报文头中发送给Web服务器，确切地说是通过报文头的Accept-Language参数将“语言首选项”对话框中选择的语言发送到服务器，成为服务器判别客户端本地化类型的依据。 SpringMVC本地化解析器 AcceptHeaderLocaleResolver：根据HTTP报文头的Accept-Language参数确定本地化类型，如果没有显式定义本地化解析器， Spring MVC默认采用AcceptHeader- LocaleResolver。 CookieLocaleResolver：根据指定Cookie值确定本地化类型。 SessionLocaleResolver：根据Session中特定的属性值确定本地化类型。 LocaleChangeInterceptor：从请求参数中获取本次请求对应的本地化类型。 LocaleChangeInterceptor：通过URL参数指定很多国际型的网站都允许通过一个请求参数控制网站的本地化，如www.xxx.com? locale=zh_CN返回对应中国大陆的本地化网页，而www.xxx.com?locale=en返回本地化为英语的网页。这样，网站使用者可以通过URL的控制返回不同本地化的页面，非常灵活。 123456789&lt;bean id=\"localeResolver\"class=\"org.springframework.web.servlet.i18n.CookieLocaleResolver\" p:cookieName=\"clientLanguage\" p:cookieMaxAge=\"100000\" p:cookiePath=\"/\" p:defaultLocale=\"zh_CN\"/&gt;&lt;mvc:interceptors&gt; &lt;bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\" /&gt;&lt;/mvc:interceptors&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://skiyubon.github.io/categories/JavaWeb/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://skiyubon.github.io/tags/SpringMVC/"}]},{"title":"Lucene","slug":"Lucene","date":"2017-04-11T11:11:44.000Z","updated":"2017-04-12T11:36:54.702Z","comments":true,"path":"2017/04/11/Lucene/","link":"","permalink":"https://skiyubon.github.io/2017/04/11/Lucene/","excerpt":"Lucene:信息检索(IR)工具库，或者称为工具箱。信息检索指文档搜索，文档内信息搜索，或者文档相关的元数据搜索等操作。Lucene允许你向自己的应用程序中添加搜索功能，其并不关心数据来源、格式、甚至不关心数据的语种、只要能把它转为文本格式即可。（服务器上的网页，本地文件系统中的文档，Word文档，XML、HTML、PDF文档，或者其他能够从中提取文本信息的数据格式）","text":"Lucene:信息检索(IR)工具库，或者称为工具箱。信息检索指文档搜索，文档内信息搜索，或者文档相关的元数据搜索等操作。Lucene允许你向自己的应用程序中添加搜索功能，其并不关心数据来源、格式、甚至不关心数据的语种、只要能把它转为文本格式即可。（服务器上的网页，本地文件系统中的文档，Word文档，XML、HTML、PDF文档，或者其他能够从中提取文本信息的数据格式） 1.初识Lucene组件列表 索引组件 搜索组件 搜索程序的其他模块（Lucene与应用程序进行整合） 管理界面 分析界面 搜索范围 入门程序示例 建立索引(核心类) IndexWriter Directory Analyzer Doucment Field 搜索索引(核心类) IndexSearch Term Query TermQuery TopDocs 2.构建索引2.1 基本索引操作（索引的CURD）2.2 在索引过程中对文档和域进行加权操作2.3 对日期、数字和可排序域进行索引2.4 高级索引技术3.搜索功能3.1 查询Lucene索引 3.2 使用Lucene的多种内置查询 对特定项的搜索 TermQuery 解析用户输入的查询表达式： QueryParser QueryParser 对象将用户输入的文本表达式用分词器转换成对应索引库中的分词形式，进一步构成复杂的查询，以提供给搜索模块。 查询表达式与数据库中使用的SQL表达式类似，因为后者必须解析成数据库服务器马上理解的更低级别的元素。 用QueryParser处理基本查询表达式：参见以下表达式以及它们转换后的形式。 3.3 处理搜索结果3.4 Lucene的评分机制3.5 解析用户输入的查询表达式4.分析过程4.1 理解分析过程4.2 Lucene的核心分析类4.3 编写自定义分析器4.4 处理非英语语种5.高级搜索技术5.1 为所有文档加载域值5.2 对搜索结果进行过滤和排序5.3 跨度查询和功能查询5.4 使用项向量5.5 停止较慢的搜索6.扩展搜索6.1 创建自定义排序6.2 使用Collector6.3 自定义QueryParser6.4 使用位置有效载荷7.下一回：Lucene应用的基本扩展、高级扩展、管理和性能调优、以及其他语言使用Lucene","categories":[{"name":"大数据","slug":"大数据","permalink":"https://skiyubon.github.io/categories/大数据/"}],"tags":[{"name":"Lucene","slug":"Lucene","permalink":"https://skiyubon.github.io/tags/Lucene/"}]},{"title":"IKAnalyzer中文分词器","slug":"IKAnalyzer中文分词器","date":"2017-04-11T09:10:20.000Z","updated":"2017-04-11T09:53:01.993Z","comments":true,"path":"2017/04/11/IKAnalyzer中文分词器/","link":"","permalink":"https://skiyubon.github.io/2017/04/11/IKAnalyzer中文分词器/","excerpt":"IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。 从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。 在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化。","text":"IK Analyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006年 12 月推出 1.0 版开始， IKAnalyzer 已经推出了 4 个大版本。最初，它是以开源项目Luence 为应用主体的，结合词典分词和文法分析算法的中文分词组件。 从 3.0 版本开始，IK 发展为面向 Java 的公用分词组件，独立亍 Lucene 项目，同时提供了对 Lucene 的默认优化实现。 在 2012 版本中，IK 实现了简单的分词歧义排除算法，标志着 IK 分词器从单纯的词典分词向模拟语义分词衍化。 简介IK Analyzer 2012 结构设计 IK Analyzer 2012 特性 采用了特有的“ 正向迭代最细粒度切分算法“ ，支持细粒度和智能分词两种切分模式； 在系统环境：Core2 i7 3.4G 双核，4G 内存，window 7 64 位， Sun JDK 1.6_29 64位 普通 pc 环境测试，IK2012 具有 160 万字/秒（3000KB/S）的高速处理能力。 2012 版本的智能分词模式支持简单的分词排歧义处理和数量词合并输出。 采用了多子处理器分析模式，支持：英文字母、数字、中文词汇等分词处理，兼容韩文、日文字符 优化的词典存储，更小的内存占用。支持用户词典扩展定义。特别的，在 2012 版本，词典支持中文，英文，数字混合词语。 分词效果示例IK Analyzer 2012 版本支持 细粒度切分 和 智能切分，以下是两种切分方式的演示样例。 文本原文 1:IKAnalyzer 是一个开源的，基亍 java 语言开发的轻量级的中文分词工具包。从 2006 年 12月推出 1.0 版开始， IKAnalyzer 已经推出了 3 个大版本。 智能分词结果:ikanalyzer | 是 | 一个 | 开源 | 的 | 基亍 | java | 语言 | 开发 | 的 | 轻量级 | 的 | 中文 | 分词 | 工具包 | 从 | 2006年 | 12月 | 推出 | 1.0版 | 开始 | ikanalyzer | 已经 | 推| 出了 | 3个 | 大 | 版本 最细粒度分词结果:ikanalyzer | 是 | 一个 | 一 | 个 | 开源 | 的 | 基亍 | java | 语言 | 开发 | 的 | 轻量级| 量级 | 的 | 中文 | 分词 | 工具包 | 工具 | 包 | 从 | 2006 | 年 | 12 | 月 | 推出 | 1.0 |版 | 开始 | ikanalyzer | 已经 | 推出 | 出了 | 3 | 个 | 大 | 版本 文本原文 2:张三说的确实在理 智能分词结果:张三 | 说的 | 确实 | 在理 最细粒度分词结果:张三 | 三 | 说的 | 的确 | 的 | 确实 | 实在 | 在理 文本原文 3公路局正在治理解放大道路面积水问题 智能分词结果:公路局 | 正在 | 治理 | 解放 | 大道 | 路面 | 积水 | 问题 最细粒度分词结果:公路局 | 公路 | 路局 | 正在 | 治理 | 理解 | 解放 | 放大 | 大道 | 道路 | 路面 | 面积| 积水 | 问题 文本原文 4据路透社报道，印度尼西亚社会事务部一官员星期二(29 日)表示，日惹市附近当地时间 27日晨 5 时 53 分发生的里氏 6.2 级地震已经造成至少 5427 人死亡，20000 余人受伤，近 20万人无家可归。 智能分词结果:据 | 路透社 | 报道 | 印度尼西亚 | 社会 | 事务部 | 一 | 官员 | 星期二 | 29 日 | 表示 |日 | 惹 | 市 | 附近 | 当地时间 | 27 日 | 晨 | 5 时 | 53 分 | 发生 | 的 | 里氏 | 6.2 级 |地震 | 已经 | 造成 | 至少 | 5427 人 | 死亡 | 20000 | 余人 | 受伤 | 近 | 20 | 万人 |无家可归 最细粒度分词结果:据 | 路透社 | 路透 | 社 | 报道 | 印度尼西亚 | 印度 | 尼 | 西亚 | 社会事务 | 社会 |事务部 | 事务 | 部 | 一 | 官员 | 星期二 | 星期 | 二 | 29 | 日 | 表示 | 日 | 惹 | 市 |附近 | 当地时间 | 当地 | 时间 | 27 | 日 | 晨 | 5 | 时 | 53 | 分发 | 分 | 发生 | 发 | 生| 的 | 里氏 | 6.2 | 级 | 地震 | 已经 | 造成 | 至少 | 5427 | 人 | 死亡 | 20000 | 余人 |受伤 | 近 | 20 | 万人 | 万 | 人 | 无家可归 使用指南下载地址：GoogleCode 开源项目 ：http://code.google.com/p/ik-analyzer/GoogleCode 下载：http://code.google.com/p/ik-analyzer/downloads/list 与相关项目的版本兼容 IK Analyzer安装包： 《 IKAnalyzer 中文分词器 V2012 使用手册》（即本文档） IKAnalyzer2012.jar（主 jar 包） IKAnalyzer.cfg.xml（分词器扩展配置文件） stopword.dic（停止词典） LICENSE.TXT ; NOTICE.TXT （apache 版权申明）它 的 安 装 部 署 十 分 简 单 ， 将 IKAnalyzer2012.jar 部 署 亍 项 目 的 lib 目 彔 中 ；IKAnalyzer.cfg.xml 不 stopword.dic 文件放置在 class 根目彔（对亍 web 项目，通常是WEB-INF/classes 目彔，同 hibernate、 log4j 等配置文件相同）下即可。 Lucene用户快速入门1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/* IKAnalyzer 示例* 2012-3-2** 以下是结合Lucene3.4 API的写法**/public class IKAnalyzerDemo &#123; public static void main(String[] args)&#123; //Lucene Document的域名 String fieldName = \"text\"; //检索内容 String text = \"IK Analyzer是一个结合词典分词和文法分词的中文分词开源工 具包。它使用了全新的正向迭代最细粒度切分算法。 \"; //实例化IKAnalyzer分词器 Analyzer analyzer = new IKAnalyzer(); Directory directory = null; IndexWriter iwriter = null; IndexReader ireader = null; IndexSearcher isearcher = null; try &#123; //建立内存索引对象 directory = new RAMDirectory(); //配置IndexWriterConfig IndexWriterConfig iwConfig = new IndexWriterConfig(Version.LUCENE_34 , analyzer); iwConfig.setOpenMode(OpenMode.CREATE_OR_APPEND); iwriter = new IndexWriter(directory , iwConfig); //写入索引 Document doc = new Document(); doc.add(new Field(\"ID\", \"10000\", Field.Store.YES, Field.Index.NOT_ANALYZED)); doc.add(new Field(fieldName, text, Field.Store.YES, Field.Index.ANALYZED)); iwriter.addDocument(doc); iwriter.close(); //搜索过程********************************** //实例化搜索器 ireader = IndexReader.open(directory);isearcher = new IndexSearcher(ireader); String keyword = \"中文分词工具包\"; //使用QueryParser查询分析器构造Query对象 QueryParser qp = new QueryParser(Version.LUCENE_34, fieldName, analyzer); qp.setDefaultOperator(QueryParser.AND_OPERATOR); Query query = qp.parse(keyword); //搜索相似度最高的5条记录 TopDocs topDocs = isearcher.search(query , 5); System.out.println(\"命中： \" + topDocs.totalHits); //输出结果 ScoreDoc[] scoreDocs = topDocs.scoreDocs; for (int i = 0; i &lt; topDocs.totalHits; i++)&#123; Document targetDoc = isearcher.doc(scoreDocs[i].doc); System.out.println(\"内容： \" + targetDoc.toString()); &#125; &#125; catch (CorruptIndexException e) &#123; e.printStackTrace(); &#125; catch (LockObtainFailedException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; finally&#123; if(ireader != null)&#123; try &#123; ireader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if(directory != null)&#123; try &#123; directory.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125;/* 执行结果： 命中： 1 内容： Document&lt;stored/uncompressed,indexed,tokenized&lt;text:IK Analyzer是 一个结合词典分词和文法分词的中文分词开源工具包。它使用了全新的正向迭代最细粒度切分算 法。 &gt;&gt;*/ 关键 API 说明（注：本文档只列出常用的、 主要的 API 说明，有可能因为版本变更而不实际代码产生丌一致情冴，因此最准确的说明请参看 Java API DOC） 类 org.wltea.analyzer.lucene.IKAnalyzer说明：IK 分词器的主类，是 IK 分词器的 Lucene Analyzer 类实现。该类使用方法请参考 “代码样例”章节 public IKAnalyzer()说明：构造函数，默认实现最细粒度切分算法 public IKAnalyzer(boolean useSmart)说明：构造函数参数 1 ：boolean useSmart， 当为 true 时，分词器采用智能切分 ；当为 false时，分词器迚行最细粒度切分。类 org.wltea.analyzer.core.IKSegmenter说明： 这是 IK 分词器的核心类。它是独立亍 Lucene 的 Java 分词器实现。当您需要在 Lucene 以外的环境中单独使用 IK 中文分词 组件时，IKSegmenter 正是您要找的。 public IKSegmenter(Reader input , boolean useSmart)说明：IK 主分词器构造函数参数 1：Reader input , 字符输入读取参数 2 : boolean useSmart , 是否采用智能切分策略。 true 使用智能切分，false 使用最细粒度切分。 public IKSegmentation(Reader input , Configuration cfg)说明：IK 主分词器新构造函数参数 1：Reader input , 字符输入读取参数 2：Configuration cfg , 分词器配置。用户可以定制自己的 Configuration 类，来改变词典配置。 public synchronized Lexeme next()throws IOException说明：读取分词器切分出的下一个语义单元，如果返回 null，表示分词器已经结束。返回值：Lexeme 语义单元对象，即相当亍 Lucene 的词元对象 Token类 org.wltea.analyzer.core.Lexeme说明： 这是 IK 分词器的语义单元对象，相当亍 Lucene 中的 Token 词元对象。 由亍IK 被设计为独立亍 Lucene 的 Java 分词器实现，因此它需要 Lexeme 来代表分词的结果。 public int getBeginPosition()说明：获取语义单元的起始字符在文本中的位置返回值：int ， 语义单元相对亍文本的绝对起始位置 public int getEndPosition()说明：获取语义单元的结束字符的下一个位置返回值：int ， 语义单元相对亍文本的绝对终止位置的下一个字符位置 public int getLength()说明：获取语义单元包含字符串的长度返回值：int ， 语义单元长度 = getEndPosition – getBeginPosition public String getLexemeText()说明：获取语义单元包含字符串内容返回值：String， 语义单元的实际内容，即分词的结果 IKQueryPaser 与 IK 简单搜索表达式说明在 IK2012 版本乊前，由亍分词器没有处理歧义分词的能力，才使用了 IKQueryParser来解决搜索时的歧义冲突问题。随着 2012 版本的推出，用户已经丌 再需要使用IKQueryParser 来解决这样的问题。直接使用 Lucene 的 QueryParser 即可。 词表扩展目前， IK 分词器自带的主词典拥有 27 万左右的汉语单词量。由亍作者个人的精力有限，并没有对搜集到的词库迚行全范围的筛选、清理。此外，对亍分词组件应用场景所涉及的领域的丌同，也需要各类与业词库的支持。为此，IK 分词器提供了对词典的扩展支持。在 IK 分词器 3.1.3 以上版本，同时提供了对用户自定义的停止词（过滤词）的扩展支持。 基于 API 的词典扩充IK 分词器支持使用 API 编程模型扩充您的词典和停止词典。如果您的个性化词典是存储亍数据库中，这个方式应该对您适用。 API 如下： 类 org.wltea.analyzer.dic.Dictionary说明： IK 分词器的词典对象。它负责中文词汇的加载，内存管理和匹配检索。 public static Dictionary initial(Configuration cfg)说明：初始化字典实例。字典采用单例模式，一旦初始化，实例就固定.PS:注意该方法只能调用一次。参数 1：Configuration cfg ， 词典路径配置返回值：Dictionary IK 词典单例 public static Dictionary getSingleton()说明：获取初始化完毕的字典单例返回值：Dictionary IK 词典单例 public void addWords(Collection words)说明：加载用户扩展的词汇列表到 IK 的主词典中，增加分词器的可识别词语。参数 1：Collection words ， 扩展的词汇列表返回值：无 public void disableWords(Collection words)说明：屏蔽词典中的词元参数 1：Collection words， 待删除的词列表返回值：无 基于配置的词典扩充IK 分词器还支持通过配置 IKAnalyzer.cfg.xml 文件来扩充您的与有词典以及停止词典（过滤词典） 。 部署 IKAnalyzer.cfg.xmlIKAnalyzer.cfg.xml 部 署 在 代 码 根 目 彔 下 （ 对 亍 web 项 目 ， 通 常 是WEB-INF/classes 目彔）同 hibernate、 log4j 等配置文件相同。 词典文件的编辑不部署分词器的词典文件格式是无 BOM 的 UTF-8 编码的中文文本文件，文件扩展名丌限。词典中，每个中文词汇独立占一行，使用\\r\\n 的 DOS 方式换行。（注，如果您丌了解什么是无 BOM 的 UTF-8 格式， 请保证您的词典使用 UTF-8 存储，并在文件的头部添加一空行）。您可以参考分词器源码 org.wltea.analyzer.dic 包下的.dic 文件。词典文件应部署在 Java 的资源路径下，即 ClassLoader 能够加载的路径中。（推荐同 IKAnalyzer.cfg.xml 放在一起） IKAnalyzer.cfg.xml 文件的配置12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\"&gt;&lt;properties&gt;&lt;comment&gt;IK Analyzer 扩展配置&lt;/comment&gt;&lt;!--用户可以在这里配置自己的扩展字典 --&gt;&lt;entry key=\"ext_dict\"&gt;/mydict.dic;/com/mycompany/dic/mydict2.dic;&lt;/entry&gt;&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;&lt;entry key=\"ext_stopwords\"&gt;/ext_stopword.dic&lt;/entry&gt;&lt;/properties&gt; 在配置文件中，用户可一次配置多个词典文件。文件名使用“ ;”号分隔。文件路径为相对 java 包的起始根路径。 使用自定义的 Configuration 类改变词典配置IK 分词器使用 org.wltea.analyzer.cfg.Configuration 接口来提供扩展字典的配置信息，在特定情冴下，用户可以根据需要，实现该接口类，定制自己的字典配置。 以下是接口方法说明： 类 org.wltea.analyzer.cfg.Configuration public String getMainDictionary()说明：获取主字典路径，注意该路径是相对不当前系统类加载器 ClassLoader 的路径。返回值：主字典路径字符串 public String getQuantifierDicionary ()说明：获取量词字典路径，注意该路径是相对不当前系统类加载器 ClassLoader的路径。返回值：量词典路径字符串 public List getExtDictionarys() ()说明：获取扩展字典路径列表，可一次返回多个扩展词典。 注意该路径是相对不当前系统类加载器 ClassLoader 的路径。返回值：扩展典路径字符串列表 public List getExtStopWordDictionarys () ()说明：获取停止词（stopword）字典路径列表，可一次返回多个停止词词典。 注意该路径是相对不当前系统类加载器 ClassLoader 的路径。返回值：停止词词典路径字符串列表针对 solr 的分词器应用扩展这里特别的罗嗦几句，在 Solr4.0 发布以后，官方取消了 BaseTokenizerFactory 接口，而直接使用 Lucene Analyzer 标准接口。因此 IK 分词器 2012 FF 版本也取消了org.wltea.analyzer.solr.IKTokenizerFactory 类。solr4.0 配置样例使用 IKAnalyzer 的配置…………更多的 solr4.0 配置方式，请参考 solr4.0 相关文档。链接地址：http://wiki.apache.org/solr/AnalyzersTokenizersTokenFilters","categories":[{"name":"大数据","slug":"大数据","permalink":"https://skiyubon.github.io/categories/大数据/"}],"tags":[{"name":"Lucene","slug":"Lucene","permalink":"https://skiyubon.github.io/tags/Lucene/"},{"name":"Analyzer","slug":"Analyzer","permalink":"https://skiyubon.github.io/tags/Analyzer/"}]},{"title":"搜索以及Lucene","slug":"搜索","date":"2017-04-11T02:10:19.000Z","updated":"2017-04-11T08:58:54.287Z","comments":true,"path":"2017/04/11/搜索/","link":"","permalink":"https://skiyubon.github.io/2017/04/11/搜索/","excerpt":"","text":"数据与搜索 数据库搜索 数据库中的搜索很容易实现，通常都是使用sql语句进行查询，而且能很快的得到查询结果。为什么数据库搜索很容易？因为数据库中的数据存储是有规律的，有行有列而且数据格式、数据长度都是固定的 数据分类 我们生活中的数据总体分为两种：结构化数据和非结构化数据。结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件 非结构化数据查询方法 （1）顺序扫描法(Serial Scanning)所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。（2）全文检索(Full-text Search)将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。 如何实现全文检索 可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。 全文检索的应用场景 对于数据量大、数据结构不固定的数据可采用全文检索方式搜索，比如百度、Google等搜索引擎、论坛站内搜索、电商网站站内搜索等。 Lucene 实现全文检索的流程 索引和搜索流程图 创建索引 对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。 获得原始文档 从互联网上、数据库、文件系统中等获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来。Lucene不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，如下：Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。jsoup（http://jsoup.org/ ），jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix 是一个由 java 开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。本案例我们要获取磁盘上文件的内容，可以通过文件流来读取文本文件的内容，对于pdf、doc、xls等文件可通过第三方提供的解析工具读取文件内容，比如Apache POI读取doc和xls的文件内容。 创建文档对象 获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。这里我们可以将磁盘上的一个文件当成一个document，Document中包括一些Field（file_name文件名称、file_path文件路径、file_size文件大小、file_content文件内容），如下图： Docuent(文档) |—— Filed(域) { Name:file_name(文件名) Value:springmvc.txt } ——| 注意：每个Document可以有多个Field，不同的Document可以有不同的Field，同一个Document可以有相同的Field（域名和域值都相同） 每个文档都有一个唯一的编号，就是文档id。 分析文档 将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。 比如下边的文档经过分析如下：原文档内容：Lucene is a Java full-text search engine. Lucene is not a completeapplication, but rather a code library and API that can easily be usedto add search capabilities to applications. 分析后得到的语汇单元：lucene、java、full、search、engine。。。。 每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。term中包含两部分一部分是文档的域名，另一部分是单词的内容。例如：文件名中包含apache和文件内容中包含的apache是不同的term。 创建索引 对所有文档分析得出的语汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索被索引的语汇单元从而找到Document（文档）。 注意：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构。传统方法是根据文件找到该文件的内容，在文件内容中匹配搜索关键字，这种方法是顺序扫描方法，数据量大、搜索慢。倒排索引结构是根据内容（词语）找文档，如下图：倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。 查询索引 查询索引也是搜索的过程。搜索就是用户输入关键字，从索引（index）中进行搜索的过程。根据关键字搜索索引，根据索引找到对应的文档，从而找到要搜索的内容（这里指磁盘上的文件）。 用户查询接口 全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。 比如： Lucene不提供制作用户搜索界面的功能，需要根据自己的需求开发搜索界面。 9.创建查询 用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询要搜索的Field文档域、查询关键字等，查询对象会生成具体的查询语法，例如：语法 “fileName:lucene”表示要搜索Field域的内容为“lucene”的文档 执行查询 搜索索引过程：根据查询语法在倒排索引词典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。比如搜索语法为“fileName:lucene”表示搜索出fileName域中包含Lucene的文档。搜索过程就是在索引上查找域为fileName，并且关键字为Lucene的term，并根据term找到文档id列表。 渲染结果 以一个友好的界面将查询结果展示给用户，用户根据搜索结果找自己想要的信息，为了帮助用户很快找到自己的结果，提供了很多展示的效果，比如搜索结果中将关键字高亮显示，百度提供的快照等。 搭建环境Lucene是开发全文检索功能的工具包，从官方网站下载Lucene4.10.3，并解压。官方网站：http://lucene.apache.org/版本：lucene4.10.3Jdk要求：1.7以上IDE：Eclipse Lucene包：lucene-core-4.10.3.jarlucene-analyzers-common-4.10.3.jarlucene-queryparser-4.10.3.jar 其它：commons-io-2.4.jarjunit-4.9.jar 功能一：创建索引库实现步骤 创建Java工程，导入jar包 创建索引库存放的位置，可以是内存也可以是磁盘 创建一个IndexWriter对象，需要一个分析器。 指定索引库的存放位置Directory对象 指定一个分析器，对文档内容进行分析。 创建document对象。 创建field对象，将field添加到document对象中。 使用indexwriter对象将document对象写入索引库，此过程进行索引创建。并将索引和document对象写入索引库。 关闭IndexWriter对象。 Field 域的属性 是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。 是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。 是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取比如：商品名称、订单号，凡是将来要从Document中获取的Field都要存储。 是否存储的标准：是否要将内容展示给用户 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //创建索引@Testpublic void createIndex() throws Exception &#123; //指定索引库存放的路径 //D:\\temp\\0108\\index Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\0108\\\\index\")); //索引库还可以存放到内存中 //Directory directory = new RAMDirectory(); //创建一个标准分析器 Analyzer analyzer = new StandardAnalyzer(); //创建indexwriterCofig对象 //第一个参数： Lucene的版本信息，可以选择对应的lucene版本也可以使用LATEST //第二根参数：分析器对象 IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, analyzer); //创建indexwriter对象 IndexWriter indexWriter = new IndexWriter(directory, config); //原始文档的路径D:\\传智播客\\01.课程\\04.lucene\\01.参考资料\\searchsource File dir = new File(\"D:\\\\传智播客\\\\01.课程\\\\04.lucene\\\\01.参考资料\\\\searchsource\"); for (File f : dir.listFiles()) &#123; //文件名 String fileName = f.getName(); //文件内容 String fileContent = FileUtils.readFileToString(f); //文件路径 String filePath = f.getPath(); //文件的大小 long fileSize = FileUtils.sizeOf(f); //创建文件名域 //第一个参数：域的名称 //第二个参数：域的内容 //第三个参数：是否存储 Field fileNameField = new TextField(\"filename\", fileName, Store.YES); //文件内容域 Field fileContentField = new TextField(\"content\", fileContent, Store.YES); //文件路径域（不分析、不索引、只存储） Field filePathField = new StoredField(\"path\", filePath); //文件大小域 Field fileSizeField = new LongField(\"size\", fileSize, Store.YES); //创建document对象 Document document = new Document(); document.add(fileNameField); document.add(fileContentField); document.add(filePathField); document.add(fileSizeField); //创建索引，并写入索引库 indexWriter.addDocument(document); &#125; //关闭indexwriter indexWriter.close();&#125; 使用Luke工具查看索引文件 功能二：查询索引实现步骤 创建一个Directory对象，也就是索引库存放的位置。 创建一个indexReader对象，需要指定Directory对象。 创建一个indexsearcher对象，需要指定IndexReader对象。 创建一个TermQuery对象，指定查询的域和查询的关键词。 执行查询。 返回查询结果。遍历查询结果并输出。 关闭IndexReader对象。 IndexSearcher搜索方法 代码实现12345678910111213141516171819202122232425262728293031 //查询索引库@Testpublic void searchIndex() throws Exception &#123; //指定索引库存放的路径 //D:\\temp\\0108\\index Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\0108\\\\index\")); //创建indexReader对象 IndexReader indexReader = DirectoryReader.open(directory); //创建indexsearcher对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //创建查询 Query query = new TermQuery(new Term(\"filename\", \"apache\")); //执行查询 //第一个参数是查询对象，第二个参数是查询结果返回的最大值 TopDocs topDocs = indexSearcher.search(query, 10); //查询结果的总条数 System.out.println(\"查询结果的总条数：\"+ topDocs.totalHits); //遍历查询结果 //topDocs.scoreDocs存储了document对象的id for (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; //scoreDoc.doc属性就是document对象的id //根据document的id找到document对象 Document document = indexSearcher.doc(scoreDoc.doc); System.out.println(document.get(\"filename\")); //System.out.println(document.get(\"content\")); System.out.println(document.get(\"path\")); System.out.println(document.get(\"size\")); &#125; //关闭indexreader对象 indexReader.close();&#125; TopDocsLucene搜索结果可通过TopDocs遍历，TopDocs类提供了少量的属性，如下： 方法或属性 说明totalHits 匹配搜索条件的总记录数scoreDocs 顶部匹配记录 注意：Search方法需要指定匹配记录数量n：indexSearcher.search(query, n)TopDocs.totalHits：是匹配索引库中所有记录的数量TopDocs.scoreDocs：匹配相关度高的前边记录数组，scoreDocs的长度小于等于search方法指定的参数n 功能三：支持中文分词分析器（Analyzer）的执行过程如下图是语汇单元的生成过程：从一个Reader字符流开始，创建一个基于Reader的Tokenizer分词器，经过三个TokenFilter生成语汇单元Token。要看分析器的分析效果，只需要看Tokenstream中的内容就可以了。每个分析器都有一个方法tokenStream，返回一个tokenStream对象。 分词器的分词： 12345678910111213141516171819202122232425 //查看标准分析器的分词效果public void testTokenStream() throws Exception &#123; //创建一个标准分析器对象 Analyzer analyzer = new StandardAnalyzer(); //获得tokenStream对象 //第一个参数：域名，可以随便给一个 //第二个参数：要分析的文本内容 TokenStream tokenStream = analyzer.tokenStream(\"test\", \"The Spring Framework provides a comprehensive programming and configuration model.\"); //添加一个引用，可以获得每个关键词 CharTermAttribute charTermAttribute = tokenStream.addAttribute(CharTermAttribute.class); //添加一个偏移量的引用，记录了关键词的开始位置以及结束位置 OffsetAttribute offsetAttribute = tokenStream.addAttribute(OffsetAttribute.class); //将指针调整到列表的头部 tokenStream.reset(); //遍历关键词列表，通过incrementToken方法判断列表是否结束 while(tokenStream.incrementToken()) &#123; //关键词的起始位置 System.out.println(\"start-&gt;\" + offsetAttribute.startOffset()); //取关键词 System.out.println(charTermAttribute); //结束位置 System.out.println(\"end-&gt;\" + offsetAttribute.endOffset()); &#125; tokenStream.close();&#125; Lucene自带中文分词器 StandardAnalyzer：单字分词：就是按照中文一个字一个字地进行分词。如：“我爱中国”，效果：“我”、“爱”、“中”、“国”。 CJKAnalyzer二分法分词：按两个字进行切分。如：“我是中国人”，效果：“我是”、“是中”、“中国”“国人”。 上边两个分词器无法满足需求。 SmartChineseAnalyzer对中文支持较好，但扩展性差，扩展词库，禁用词库和同义词库等不好处理 第三方分词器 paoding： 庖丁解牛最新版在 https://code.google.com/p/paoding/ 中最多支持Lucene 3.0，且最新提交的代码在 2008-06-03，在svn中最新也是2010年提交，已经过时，不予考虑。 mmseg4j：最新版已从 https://code.google.com/p/mmseg4j/ 移至 https://github.com/chenlb/mmseg4j-solr，支持Lucene 4.10，且在github中最新提交代码是2014年6月，从09年～14年一共有：18个版本，也就是一年几乎有3个大小版本，有较大的活跃度，用了mmseg算法。 IK-analyzer： 最新版在https://code.google.com/p/ik-analyzer/上，支持Lucene 4.10从2006年12月推出1.0版开始， IKAnalyzer已经推出了4个大版本。最初，它是以开源项目Luence为应用主体的，结合词典分词和文法分析算法的中文分词组件。从3.0版本开 始，IK发展为面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。在2012版本中，IK实现了简单的分词 歧义排除算法，标志着IK分词器从单纯的词典分词向模拟语义分词衍化。 但是也就是2012年12月后没有在更新。 ansj_seg：最新版本在 https://github.com/NLPchina/ansj_seg tags仅有1.1版本，从2012年到2014年更新了大小6次，但是作者本人在2014年10月10日说明：“可能我以后没有精力来维护ansj_seg了”，现在由”nlp_china”管理。2014年11月有更新。并未说明是否支持Lucene，是一个由CRF（条件随机场）算法所做的分词算法。 imdict-chinese-analyzer：最新版在 https://code.google.com/p/imdict-chinese-analyzer/ ， 最新更新也在2009年5月，下载源码，不支持Lucene 4.10 。是利用HMM（隐马尔科夫链）算法。 Jcseg：最新版本在git.oschina.net/lionsoul/jcseg，支持Lucene 4.10，作者有较高的活跃度。利用mmseg算法。 功能四：索引库的维护1.索引库的添加文档向索引库中添加document对象。 先创建一个indexwriter对象 创建一个document对象 把document对象写入索引库 关闭indexwriter。 1234567891011121314151617181920212223//添加索引@Testpublic void addDocument() throws Exception &#123; //索引库存放路径 Directory directory = FSDirectory.open(new File(\"D:\\\\temp\\\\0108\\\\index\")); IndexWriterConfig config = new IndexWriterConfig(Version.LATEST, new IKAnalyzer()); //创建一个indexwriter对象 IndexWriter indexWriter = new IndexWriter(directory, config); //创建一个Document对象 Document document = new Document(); //向document对象中添加域。 //不同的document可以有不同的域，同一个document可以有相同的域。 document.add(new TextField(\"filename\", \"新添加的文档\", Store.YES)); document.add(new TextField(\"content\", \"新添加的文档的内容\", Store.NO)); document.add(new TextField(\"content\", \"新添加的文档的内容第二个content\", Store.YES)); document.add(new TextField(\"content1\", \"新添加的文档的内容要能看到\", Store.YES)); //添加文档到索引库 indexWriter.addDocument(document); //关闭indexwriter indexWriter.close(); &#125; 2.删除全部文档123456789//删除全部索引@Testpublic void deleteAllIndex() throws Exception &#123; IndexWriter indexWriter = getIndexWriter(); //删除全部索引 indexWriter.deleteAll(); //关闭indexwriter indexWriter.close();&#125; 说明：将索引目录的索引信息全部删除，直接彻底删除，无法恢复。此方法慎用！！ 3.指定查询条件删除1234567891011//根据查询条件删除索引@Testpublic void deleteIndexByQuery() throws Exception &#123; IndexWriter indexWriter = getIndexWriter(); //创建一个查询条件 Query query = new TermQuery(new Term(\"filename\", \"apache\")); //根据查询条件删除 indexWriter.deleteDocuments(query); //关闭indexwriter indexWriter.close();&#125; 4.更新索引库原理就是先删除后添加1234567891011121314//修改索引库 @Test public void updateIndex() throws Exception &#123; IndexWriter indexWriter = getIndexWriter(); //创建一个Document对象 Document document = new Document(); //向document对象中添加域。 //不同的document可以有不同的域，同一个document可以有相同的域。 document.add(new TextField(\"filename\", \"要更新的文档\", Store.YES)); document.add(new TextField(\"content\", \"2013年11月18日 - Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,它不是一个完整的搜索应用程序,而是为你的应用程序提供索引和搜索功能。\", Store.YES)); indexWriter.updateDocument(new Term(\"content\", \"java\"), document); //关闭indexWriter indexWriter.close(); &#125;","categories":[{"name":"大数据","slug":"大数据","permalink":"https://skiyubon.github.io/categories/大数据/"}],"tags":[{"name":"Lucene","slug":"Lucene","permalink":"https://skiyubon.github.io/tags/Lucene/"}]},{"title":"Sublime Text 3 快捷键精华版","slug":"sublime3shortcuts ","date":"2017-04-10T15:38:28.000Z","updated":"2017-04-10T16:05:09.090Z","comments":true,"path":"2017/04/10/sublime3shortcuts /","link":"","permalink":"https://skiyubon.github.io/2017/04/10/sublime3shortcuts /","excerpt":"","text":"Ctrl+Shift+P：打开命令面板Ctrl+P：搜索项目中的文件Ctrl+G：跳转到第几行Ctrl+W：关闭当前打开文件Ctrl+Shift+W：关闭所有打开文件Ctrl+Shift+V：粘贴并格式化Ctrl+D：选择单词，重复可增加选择下一个相同的单词Ctrl+L：选择行，重复可依次增加选择下一行Ctrl+Shift+L：选择多行Ctrl+Shift+Enter：在当前行前插入新行Ctrl+X：删除当前行Ctrl+M：跳转到对应括号Ctrl+U：软撤销，撤销光标位置Ctrl+J：选择标签内容Ctrl+F：查找内容Ctrl+Shift+F：查找并替换Ctrl+H：替换Ctrl+R：前往 methodCtrl+N：新建窗口Ctrl+K+B：开关侧栏Ctrl+Shift+M：选中当前括号内容，重复可选着括号本身Ctrl+F2：设置/删除标记Ctrl+/：注释当前行Ctrl+Shift+/：当前位置插入注释Ctrl+Alt+/：块注释，并Focus到首行，写注释说明用的Ctrl+Shift+A：选择当前标签前后，修改标签用的F11：全屏Shift+F11：全屏免打扰模式，只编辑当前文件Alt+F3：选择所有相同的词Alt+.：闭合标签Alt+Shift+数字：分屏显示Alt+数字：切换打开第N个文件Shift+右键拖动：光标多不，用来更改或插入列内容鼠标的前进后退键可切换Tab文件按Ctrl，依次点击或选取，可需要编辑的多个位置按Ctrl+Shift+上下键，可替换行 选择类Ctrl+D 选中光标所占的文本，继续操作则会选中下一个相同的文本。Alt+F3 选中文本按下快捷键，即可一次性选择全部的相同文本进行同时编辑。举个栗子：快速选中并更改所有相同的变量名、函数名等。Ctrl+L 选中整行，继续操作则继续选择下一行，效果和 Shift+↓ 效果一样。Ctrl+Shift+L 先选中多行，再按下快捷键，会在每行行尾插入光标，即可同时编辑这些行。Ctrl+Shift+M 选择括号内的内容（继续选择父括号）。举个栗子：快速选中删除函数中的代码，重写函数体代码或重写括号内里的内容。Ctrl+M 光标移动至括号内结束或开始的位置。Ctrl+Enter 在下一行插入新行。举个栗子：即使光标不在行尾，也能快速向下插入一行。Ctrl+Shift+Enter 在上一行插入新行。举个栗子：即使光标不在行首，也能快速向上插入一行。Ctrl+Shift+[ 选中代码，按下快捷键，折叠代码。Ctrl+Shift+] 选中代码，按下快捷键，展开代码。Ctrl+K+0 展开所有折叠代码。Ctrl+← 向左单位性地移动光标，快速移动光标。Ctrl+→ 向右单位性地移动光标，快速移动光标。shift+↑ 向上选中多行。shift+↓ 向下选中多行。Shift+← 向左选中文本。Shift+→ 向右选中文本。Ctrl+Shift+← 向左单位性地选中文本。Ctrl+Shift+→ 向右单位性地选中文本。Ctrl+Shift+↑ 将光标所在行和上一行代码互换（将光标所在行插入到上一行之前）。Ctrl+Shift+↓ 将光标所在行和下一行代码互换（将光标所在行插入到下一行之后）。Ctrl+Alt+↑ 向上添加多行光标，可同时编辑多行。Ctrl+Alt+↓ 向下添加多行光标，可同时编辑多行。 编辑类Ctrl+J 合并选中的多行代码为一行。举个栗子：将多行格式的CSS属性合并为一行。Ctrl+Shift+D 复制光标所在整行，插入到下一行。Tab 向右缩进。Shift+Tab 向左缩进。Ctrl+K+K 从光标处开始删除代码至行尾。Ctrl+Shift+K 删除整行。Ctrl+/ 注释单行。Ctrl+Shift+/ 注释多行。Ctrl+K+U 转换大写。Ctrl+K+L 转换小写。Ctrl+Z 撤销。Ctrl+Y 恢复撤销。Ctrl+U 软撤销，感觉和 Gtrl+Z 一样。Ctrl+F2 设置书签Ctrl+T 左右字母互换。F6 单词检测拼写 搜索类Ctrl+F 打开底部搜索框，查找关键字。Ctrl+shift+F 在文件夹内查找，与普通编辑器不同的地方是sublime允许添加多个文件夹进行查找，略高端，未研究。Ctrl+P 打开搜索框。举个栗子：1、输入当前项目中的文件名，快速搜索文件，2、输入@和关键字，查找文件中函数名，3、输入：和数字，跳转到文件中该行代码，4、输入#和关键字，查找变量名。Ctrl+G 打开搜索框，自动带：，输入数字跳转到该行代码。举个栗子：在页面代码比较长的文件中快速定位。Ctrl+R 打开搜索框，自动带@，输入关键字，查找文件中的函数名。举个栗子：在函数较多的页面快速查找某个函数。Ctrl+： 打开搜索框，自动带#，输入关键字，查找文件中的变量名、属性名等。Ctrl+Shift+P 打开命令框。场景栗子：打开命名框，输入关键字，调用sublime text或插件的功能，例如使用package安装插件。Esc 退出光标多行选择，退出搜索框，命令框等。 显示类Ctrl+Tab 按文件浏览过的顺序，切换当前窗口的标签页。Ctrl+PageDown 向左切换当前窗口的标签页。Ctrl+PageUp 向右切换当前窗口的标签页。Alt+Shift+1 窗口分屏，恢复默认1屏（非小键盘的数字）Alt+Shift+2 左右分屏-2列Alt+Shift+3 左右分屏-3列Alt+Shift+4 左右分屏-4列Alt+Shift+5 等分4屏Alt+Shift+8 垂直分屏-2屏Alt+Shift+9 垂直分屏-3屏Ctrl+K+B 开启/关闭侧边栏。F11 全屏模式Shift+F11 免打扰模式 配置编译环境控制台输入（以C++为例）原理很简单，就是在外部建立一个用来执行文件的 bat，然后调用它。注意的就是，需要用start 来打开一个新窗口，同时需要 pause 一下来看结果，其中很蛋疼的就是Sublime默认后台执行你的start，如果你的pause和start放在一个文件了pause对start %1 的文件是无效的，因此其实需要建立两个文件。注意环境变量。。。（关于什么是环境变量，三两句解释不清楚，最好自己百度一下。）配好之后个人感觉控制台输入意义不是很大，做题的话都是从文件读入，做开发基本不需要读入。So~ 各位慎重。MyCRun.bat@echo off%1echo.echo ——————-pauseexit MyCallRun.bat@start MyCRun %1配置文件在 Sublime Text 3\\Packages\\C++.sublime-package 。 先备份一下。修改里面的 C++.sublime-build 为{ “shell_cmd”: “g++ \\”${file}\\” -o \\”${file_path}/${file_base_name}\\””, “file_regex”: “^(..[^:]):([0-9]+):?([0-9]+)?:? (.)$”, “working_dir”: “${file_path}”, “selector”: “source.c, source.c++”, “variants”: [ { “name”: “Run”, “shell_cmd”: “g++ \\”${file}\\” -o \\”${file_path}/${file_base_name}\\” &amp;&amp; MyCallRun \\”${file_path}/${file_base_name}.exe\\”” // 其实就是这里加了个MyCallRun } ]}C/C++Sublime Text 3 默认配置好了 c++ 。但是需要你自己把 gcc 目录添加进环境变量JavaSublime Text 3 默认只运行了 javac，需要自己添加运行。苦逼看不懂 Sublime 的命令格式，于是把 javac 改成一个自己的bat。（感觉也可以像C++那样用 &amp;&amp; 连起来）在命令行可直接访问的地方建立 myJRun.bat （我直接放在 jdk/bin 下了）@ECHO OFFcd %~dp1ECHO Compiling %~nx1…IF EXIST %~n1.class (DEL %~n1.class)javac %~nx1IF EXIST %~n1.class (ECHO Running…ECHO ———————-OUTPUT———————-java %~n1)注意不能使用 cls 。修改java的编译选项（备份好原来的）。目录：Packages/Java.sublime-package/JavaC.sublime-build{ “shell_cmd”: “myJRun.bat \\”$file\\””, “file_regex”: “^(…?):([0-9]):?([0-9]*)”, “selector”: “source.java”}这样以后写的Java代码点 Build 就会自动运行了。这种办法不能跨平台，再研究研究Sublime自己的方式。Go用 Sublime 开发 golang 的环境很简单，只需要安装一个 GoSublime 就差不多了。","categories":[],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://skiyubon.github.io/tags/Tool/"}]},{"title":"hexo基本使用","slug":"Hexo基本使用","date":"2017-04-10T15:38:28.000Z","updated":"2017-06-26T03:51:52.209Z","comments":true,"path":"2017/04/10/Hexo基本使用/","link":"","permalink":"https://skiyubon.github.io/2017/04/10/Hexo基本使用/","excerpt":"","text":"安装npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 基本命令hexo n &quot;my blog&quot; == hexo new &quot;my blog&quot; #新建文章 hexo p == hexo publishhexo g == hexo generate#生成静态网页 hexo s == hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo d == hexo deploy#将.deploy目录部署到 GitHubhexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo generate --deploy hexo deploy --generate hexo deploy -g hexo server -g 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。 hexo server -s #静态模式 hexo server -p 5000 #更改端口 hexo server -i 192.168.1.1 #自定义 IP 监视文件变动hexo generate --watch #监视文件变动 草稿hexo publish [layout] &lt;title&gt; 模版hexo new &quot;postName&quot;#新建文章 hexo new page &quot;pageName&quot;#新建页面 hexo generate#生成静态页面至public目录 hexo server#开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy#将.deploy目录部署到GitHub hexo new [layout] &lt;title&gt; hexo new photo &quot;My Gallery&quot; hexo new &quot;Hello World&quot; --lang tw 变量 描述 layout 布局 title 标题 date 文件建立日期 title: 使用Hexo搭建个人博客 layout: post date: 2014-03-03 19:07:43 comments: true categories: Blog tags: [Hexo] keywords: Hexo, Blog description: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。 设置文章摘要以上是文章摘要 &lt;!--more--&gt; 以下是余下全文 写作hexo new page &lt;title&gt; hexo new post &lt;title&gt; 变量 描述 :title 标题 :year 建立的年份（4 位数） :month 建立的月份（2 位数） :i_month 建立的月份（去掉开头的零） :day 建立的日期（2 位数） :i_day 建立的日期（去掉开头的零） 推送到服务器上hexo n#写文章 hexo g#生成 hexo d#部署 # 可 与 hexo g 合并为 hexo d -g 报错1.找不到git部署ERROR Deployer not found: git **解决方法** npm install hexo-deployer-git --save 2.部署类型设置githexo 3.0 部署类型不再是github，_config.yml中修改 # Deployment ## Docs: http://hexo.io/docs/deployment.html deploy: type: git repository: git@***.github.com:***/***.github.io.git branch: master 3. xcodebuildxcode-select: error: tool &apos;xcodebuild&apos; requires Xcode, but active developer directory &apos;/Library/Developer/CommandLineTools&apos; is a command line tools instance npm install hexo-generator-feed –save 4. RSS不显示安装RSS插件 npm install hexo-generator-feed --save 开启RSS功能 编辑hexo/_config.yml，添加如下代码： rss: /atom.xml #rss地址 默认即可 开启评论 1.我使用多说代替自带的评论，在[多说](http://duoshuo.com/) 网站注册 &gt; 后台管理 &gt; 添加新站点 &gt;工具 === 复制通用代码 里面有 short_name 1 在根目录 _config.yml 添加一行 disqus_shortname: jslite是在多说注册时产生的 2复制到 themes\\landscape\\layout\\_partial\\article.ejs 把 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt;&lt;section id=&quot;comments&quot;&gt;&lt;div id=&quot;disqus_thread&quot;&gt; &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/section&gt;&lt;% } %&gt; 改为 &lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname){ %&gt; &lt;section id=&quot;comments&quot;&gt; &lt;!-- 多说评论框 start --&gt; &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot; data-title=&quot;&lt;%= post.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div&gt; &lt;!-- 多说评论框 end --&gt; &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt; &lt;script type=&quot;text/javascript&quot;&gt; var duoshuoQuery = {short_name:&apos;&lt;%= config.disqus_shortname %&gt;&apos;}; (function() { var ds = document.createElement(&apos;script&apos;); ds.type = &apos;text/javascript&apos;;ds.async = true; ds.src = (document.location.protocol == &apos;https:&apos; ? &apos;https:&apos; : &apos;http:&apos;) + &apos;//static.duoshuo.com/embed.js&apos;; ds.charset = &apos;UTF-8&apos;; (document.getElementsByTagName(&apos;head&apos;)[0] || document.getElementsByTagName(&apos;body&apos;)[0]).appendChild(ds); })(); &lt;/script&gt; &lt;!-- 多说公共JS代码 end --&gt; &lt;/section&gt; &lt;% } %&gt;","categories":[{"name":"Tool","slug":"Tool","permalink":"https://skiyubon.github.io/categories/Tool/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://skiyubon.github.io/tags/hexo/"}]},{"title":"NPM 使用介绍","slug":"npm01","date":"2017-04-10T15:38:28.000Z","updated":"2017-04-11T09:58:18.724Z","comments":true,"path":"2017/04/10/npm01/","link":"","permalink":"https://skiyubon.github.io/2017/04/10/npm01/","excerpt":"","text":"NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：允许用户从NPM服务器下载别人编写的第三方包到本地使用。允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。由于新版的nodejs已经集成了npm，所以之前npm也一并安装好了。同样可以通过输入 “npm -v” 来测试是否成功安装。命令如下，出现版本提示表示安装成功:$ npm -v2.3.0如果你安装的是旧版本的 npm，可以很容易得通过 npm 命令来升级，命令如下：$ sudo npm install npm -g/usr/local/bin/npm -&gt; /usr/local/lib/node_modules/npm/bin/npm-cli.jsnpm@2.14.2 /usr/local/lib/node_modules/npm如果是 Window 系统使用以下命令即可：npm install npm -g使用淘宝镜像的命令：cnpm install npm -g使用 npm 命令安装模块npm 安装 Node.js 模块语法格式如下：$ npm install 以下实例，我们使用 npm 命令安装常用的 Node.js web框架模块 express:$ npm install express安装好之后，express 包就放在了工程目录下的 node_modules 目录中，因此在代码中只需要通过 require(‘express’) 的方式就好，无需指定第三方包路径。var express = require(‘express’);全局安装与本地安装npm 的包安装分为本地安装（local）、全局安装（global）两种，从敲的命令行来看，差别只是有没有-g而已，比如npm install express # 本地安装npm install express -g # 全局安装如果出现以下错误：npm err! Error: connect ECONNREFUSED 127.0.0.1:8087解决办法为：$ npm config set proxy null本地安装 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。如果你希望具备两者功能，则需要在两个地方安装它或使用 npm link。接下来我们使用全局方式安装 express$ npm install express -g安装过程输出如下内容，第一行输出了模块的版本号及安装位置。express@4.13.3 node_modules/express├── escape-html@1.0.2├── range-parser@1.0.2├── merge-descriptors@1.0.0├── array-flatten@1.1.1├── cookie@0.1.3├── utils-merge@1.0.0├── parseurl@1.3.0├── cookie-signature@1.0.6├── methods@1.1.1├── fresh@0.3.0├── vary@1.0.1├── path-to-regexp@0.1.7├── content-type@1.0.1├── etag@1.7.0├── serve-static@1.10.0├── content-disposition@0.5.0├── depd@1.0.1├── qs@4.0.0├── finalhandler@0.4.0 (unpipe@1.0.0)├── on-finished@2.3.0 (ee-first@1.1.1)├── proxy-addr@1.0.8 (forwarded@0.1.0, ipaddr.js@1.0.1)├── debug@2.2.0 (ms@0.7.1)├── type-is@1.6.8 (media-typer@0.3.0, mime-types@2.1.6)├── accepts@1.2.12 (negotiator@0.5.3, mime-types@2.1.6)└── send@0.13.0 (destroy@1.0.3, statuses@1.2.1, ms@0.7.1, mime@1.3.4, http-errors@1.3.1)查看安装信息你可以使用以下命令来查看所有全局安装的模块：$ npm list -g ├─┬ cnpm@4.3.2│ ├── auto-correct@1.0.0│ ├── bagpipe@0.3.5│ ├── colors@1.1.2│ ├─┬ commander@2.9.0│ │ └── graceful-readlink@1.0.1│ ├─┬ cross-spawn@0.2.9│ │ └── lru-cache@2.7.3……如果要查看某个模块的版本号，可以使用命令如下：$ npm list grunt projectName@projectVersion /path/to/project/folder└── grunt@0.4.1使用 package.jsonpackage.json 位于模块的目录下，用于定义包的属性。接下来让我们来看下 express 包的 package.json 文件，位于 node_modules/express/package.json 内容：{ “name”: “express”, “description”: “Fast, unopinionated, minimalist web framework”, “version”: “4.13.3”, “author”: { “name”: “TJ Holowaychuk”, “email”: “tj@vision-media.ca“ }, “contributors”: [ { “name”: “Aaron Heckmann”, “email”: “aaron.heckmann+github@gmail.com“ }, { “name”: “Ciaran Jessup”, “email”: “ciaranj@gmail.com“ }, { “name”: “Douglas Christopher Wilson”, “email”: “doug@somethingdoug.com“ }, { “name”: “Guillermo Rauch”, “email”: “rauchg@gmail.com“ }, { “name”: “Jonathan Ong”, “email”: “me@jongleberry.com“ }, { “name”: “Roman Shtylman”, “email”: “shtylman+expressjs@gmail.com“ }, { “name”: “Young Jae Sim”, “email”: “hanul@hanul.me“ } ], “license”: “MIT”, “repository”: { “type”: “git”, “url”: “git+https://github.com/strongloop/express.git&quot; }, “homepage”: “http://expressjs.com/&quot;, “keywords”: [ “express”, “framework”, “sinatra”, “web”, “rest”, “restful”, “router”, “app”, “api” ], “dependencies”: { “accepts”: “~1.2.12”, “array-flatten”: “1.1.1”, “content-disposition”: “0.5.0”, “content-type”: “~1.0.1”, “cookie”: “0.1.3”, “cookie-signature”: “1.0.6”, “debug”: “~2.2.0”, “depd”: “~1.0.1”, “escape-html”: “1.0.2”, “etag”: “~1.7.0”, “finalhandler”: “0.4.0”, “fresh”: “0.3.0”, “merge-descriptors”: “1.0.0”, “methods”: “~1.1.1”, “on-finished”: “~2.3.0”, “parseurl”: “~1.3.0”, “path-to-regexp”: “0.1.7”, “proxy-addr”: “~1.0.8”, “qs”: “4.0.0”, “range-parser”: “~1.0.2”, “send”: “0.13.0”, “serve-static”: “~1.10.0”, “type-is”: “~1.6.6”, “utils-merge”: “1.0.0”, “vary”: “~1.0.1” }, “devDependencies”: { “after”: “0.8.1”, “ejs”: “2.3.3”, “istanbul”: “0.3.17”, “marked”: “0.3.5”, “mocha”: “2.2.5”, “should”: “7.0.2”, “supertest”: “1.0.1”, “body-parser”: “~1.13.3”, “connect-redis”: “~2.4.1”, “cookie-parser”: “~1.3.5”, “cookie-session”: “~1.2.0”, “express-session”: “~1.11.3”, “jade”: “~1.11.0”, “method-override”: “~2.3.5”, “morgan”: “~1.6.1”, “multiparty”: “~4.1.2”, “vhost”: “~3.0.1” }, “engines”: { “node”: “&gt;= 0.10.0” }, “files”: [ “LICENSE”, “History.md”, “Readme.md”, “index.js”, “lib/“ ], “scripts”: { “test”: “mocha –require test/support/env –reporter spec –bail –check-leaks test/ test/acceptance/“, “test-ci”: “istanbul cover node_modules/mocha/bin/_mocha –report lcovonly – –require test/support/env –reporter spec –check-leaks test/ test/acceptance/“, “test-cov”: “istanbul cover node_modules/mocha/bin/_mocha – –require test/support/env –reporter dot –check-leaks test/ test/acceptance/“, “test-tap”: “mocha –require test/support/env –reporter tap –check-leaks test/ test/acceptance/“ }, “gitHead”: “ef7ad681b245fba023843ce94f6bcb8e275bbb8e”, “bugs”: { “url”: “https://github.com/strongloop/express/issues&quot; }, “_id”: “express@4.13.3“, “_shasum”: “ddb2f1fb4502bf33598d2b032b037960ca6c80a3”, “_from”: “express@*”, “_npmVersion”: “1.4.28”, “_npmUser”: { “name”: “dougwilson”, “email”: “doug@somethingdoug.com“ }, “maintainers”: [ { “name”: “tjholowaychuk”, “email”: “tj@vision-media.ca“ }, { “name”: “jongleberry”, “email”: “jonathanrichardong@gmail.com“ }, { “name”: “dougwilson”, “email”: “doug@somethingdoug.com“ }, { “name”: “rfeng”, “email”: “enjoyjava@gmail.com“ }, { “name”: “aredridel”, “email”: “aredridel@dinhe.net“ }, { “name”: “strongloop”, “email”: “callback@strongloop.com“ }, { “name”: “defunctzombie”, “email”: “shtylman@gmail.com“ } ], “dist”: { “shasum”: “ddb2f1fb4502bf33598d2b032b037960ca6c80a3”, “tarball”: “http://registry.npmjs.org/express/-/express-4.13.3.tgz&quot; }, “directories”: {}, “_resolved”: “https://registry.npmjs.org/express/-/express-4.13.3.tgz&quot;, “readme”: “ERROR: No README data found!”}Package.json 属性说明name - 包名。version - 包的版本号。description - 包的描述。homepage - 包的官网 url 。author - 包的作者姓名。contributors - 包的其他贡献者姓名。dependencies - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。repository - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。main - main 字段是一个模块ID，它是一个指向你程序的主要项目。就是说，如果你包的名字叫 express，然后用户安装它，然后require(“express”)。keywords - 关键字卸载模块我们可以使用以下命令来卸载 Node.js 模块。$ npm uninstall express卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看：$ npm ls更新模块我们可以使用以下命令更新模块：$ npm update express搜索模块使用以下来搜索模块：$ npm search express创建模块创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults. See npm help json for definitive documentation on these fieldsand exactly what they do. Use npm install &lt;pkg&gt; --save afterwards to install a package andsave it as a dependency in the package.json file. Press ^C at any time to quit.name: (node_modules) runoob # 模块名version: (1.0.0)description: Node.js 测试模块(www.runoob.com) # 描述entry point: (index.js)test command: make testgit repository: https://github.com/runoob/runoob.git # Github 地址keywords:author:license: (ISC)About to write to ……/node_modules/package.json: # 生成地址 { “name”: “runoob”, “version”: “1.0.0”, “description”: “Node.js 测试模块(www.runoob.com)&quot;, ……} Is this ok? (yes) yes以上的信息，你需要根据你自己的情况输入。在最后输入 “yes” 后会生成 package.json 文件。接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）：$ npm adduserUsername: mcmohdPassword:Email: (this IS public) mcmohd@gmail.com接下来我们就用以下命令来发布模块：$ npm publish如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。版本号使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。如果只是修复bug，需要更新Z位。如果是新增了功能，但是向下兼容，需要更新Y位。如果有大变动，向下不兼容，需要更新X位。版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。NPM支持的所有版本号范围指定方式可以查看官方文档。NPM 常用命令除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。除了可以在npmjs.org/doc/查看官方文档外，这里再介绍一些NPM常用命令。NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。使用npm help 可查看某条命令的详细帮助，例如npm help install。在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。使用npm update -g可以把全局安装的对应命令行程序更新至最新版。使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。使用npm unpublish @可以撤销发布自己发布过的某个版本代码。使用淘宝 NPM 镜像大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:$ npm install -g cnpm –registry=https://registry.npm.taobao.org这样就可以使用 cnpm 命令来安装模块了：$ cnpm install [name]","categories":[],"tags":[{"name":"Tool","slug":"Tool","permalink":"https://skiyubon.github.io/tags/Tool/"}]},{"title":"Springmvc初识","slug":"springmvc初识","date":"2017-04-10T15:38:28.000Z","updated":"2017-04-11T09:55:47.888Z","comments":true,"path":"2017/04/10/springmvc初识/","link":"","permalink":"https://skiyubon.github.io/2017/04/10/springmvc初识/","excerpt":"","text":"1.SpringMVC与Struts20 SpringMVC基于web的应用系统,特别是状态管理、工作流以及验证都是需要解决的重要功能。http协议的无状态性决定了这些功能都不容易实现。spring 的web框架就是为帮助你解决这方面而设计的。 使用spring，你可以让它的web框架自动将传递进来的请求参数填充到你的模型对象中，同时提供验证和错误处理。你可以依赖这个框架，让它帮你管理用户在web表单中创建的对象的状态。 除了这些功能外，会发现整个框架都是模块化的。每个组件都有自己的特定任务，完全与框架中的其他部分没有耦合。这让你能够用插件的方式进行web应用程序的前台开发。 1.1 struts2Struts2也是比较优秀的MVC构架，优点非常多比如良好的结构。但这里想说的是缺点，Struts2由于采用了值栈、OGNL表达式、struts2标签库等，会导致应用的性能下降。Struts2的多层拦截器、多实例action性能都很好。可以参考我写的一篇关于Spring MVC与Struts2与Servlet比较的文章 1.2 springmvc的优点 Spring3 MVC的学习难度小于Struts2，Struts2用不上的多余功能太多。呵呵，当然这不是决定因素。 Spring3 MVC很容易就可以写出性能优秀的程序，Struts2要处处小心才可以写出性能优秀的程序（指MVC部分） Spring3 MVC的灵活是你无法想像的，Spring的扩展性有口皆碑，Spring3 MVC当然也不会落后，不会因使用了MVC框架而感到有任何的限制。 1.3 SpringMVC:Model-View-Control框架性质的C 层要完成的主要工作：封装web 请求为一个数据对象、调用业务逻辑层来处理数据对象、返回处理数据结果及相应的视图给用户。 Spring C 层框架的核心是 DispatcherServlet，它的作用是将请求分发给不同的后端处理器，也即 使用了一种被称为Front Controller 的模式（后面对此模式有简要说明）。 Spring 的C 层框架使用了后端控制器来、映射处理器和视图解析器来共同完成C 层框架的主要工作。并且spring 的C 层框架还真正地把业务层处理的数据结果和相应的视图拼成一个对象，即我们后面会经常用到的ModelAndView 对象。 2 入门2.1 搭建环境在spring 的官方API 文档中，给出所有包的作用概述，现列举常用的包及相关作用：org.springframework.aop-3.0.5.RELEASE.jar ：与Aop 编程相关的包org.springframework.beans-3.0.5.RELEASE.jar ：提供了简捷操作bean 的接口org.springframework.context-3.0.5.RELEASE.jar ：构建在beans 包基础上，用来处理资源文件及国际化。org.springframework.core-3.0.5.RELEASE.jar ：spring 核心包org.springframework.web-3.0.5.RELEASE.jar ：web 核心包，提供了web 层接口spring-web-4.1.3.RELEASE.jar ：web 层的一个具体实现包，DispatcherServlet也位于此包中。 后文全部在spring3.0 版本中进行，为了方便，建议在搭建环境中导入spring3.0 的所有jar 包（所有jar 包位于dist 目录下）。 2.3 编写web.xml配置文件123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\"xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2eehttp://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"&gt;&lt;servlet&gt;&lt;servlet-name&gt;spmvc&lt;/servlet-name&gt;&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;&lt;servlet-name&gt;spmvc&lt;/servlet-name&gt;&lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;/web-app&gt; 简要说明 ：DispatcherServlet 就是一个Servlet ，也是对请求进行转发的核心Servlet 。在这里即所有.do 的请求将首先被DispatcherServlet 处理，而DispatcherServlet 它要作的工作就是对请求进行分发（也即是说把请求转发给具体的Controller ）。可以简单地认为，它就是一个总控处理器，但事实上它除了具备总控处理理器对请求进行分发的能力外，还与spring 的IOC 容器完全集成在一起，从而可以更好地使用spring 的其它功能。在这里还需留意 &lt; servlet-name &gt; spmvc &lt;/ servlet-name &gt; ，下面步骤三会用到。 2.4 建立springmvc的配置文件12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:task=\"http://www.springframework.org/schema/task\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 加载属性文件 --&gt; &lt;context:property-placeholder location=\"classpath:resource.properties\"/&gt; &lt;!-- 配置扫描 器 --&gt; &lt;context:component-scan base-package=\"cn.itcast.core.web.controller\"/&gt; &lt;!-- 配置处理器映射器 适配器 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 配置视图解释器 jsp --&gt; &lt;bean id=\"jspViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt; &lt;!-- 配置静态资源--&gt; &lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt; &lt;mvc:resources location=\"/fonts/\" mapping=\"/fonts/**\"/&gt; &lt;mvc:resources location=\"/js/\" mapping=\"/js/**\"/&gt; &lt;mvc:resources location=\"/jsp/\" mapping=\"/jsp/**\"/&gt;&lt;/beans&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://skiyubon.github.io/categories/JavaWeb/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://skiyubon.github.io/tags/SpringMVC/"}]},{"title":"Node.js 创建第一个应用","slug":"node.js-01","date":"2017-04-10T15:38:28.000Z","updated":"2017-04-11T10:01:06.640Z","comments":true,"path":"2017/04/10/node.js-01/","link":"","permalink":"https://skiyubon.github.io/2017/04/10/node.js-01/","excerpt":"","text":"如果我们使用PHP来编写后端的代码时，需要Apache 或者 Nginx 的HTTP 服务器，并配上 mod_php5 模块和php-cgi。从这个角度看，整个”接收 HTTP 请求并提供 Web 页面”的需求根本不需 要 PHP 来处理。不过对 Node.js 来说，概念完全不一样了。使用 Node.js 时，我们不仅仅 在实现一个应用，同时还实现了整个 HTTP 服务器。事实上，我们的 Web 应用以及对应的 Web 服务器基本上是一样的。在我们创建 Node.js 第一个 “Hello, World!” 应用前，让我们先了解下 Node.js 应用是由哪几部分组成的：引入 required 模块：我们可以使用 require 指令来载入 Node.js 模块。创建服务器：服务器可以监听客户端的请求，类似于 Apache 、Nginx 等 HTTP 服务器。接收请求与响应请求 服务器很容易创建，客户端可以使用浏览器或终端发送 HTTP 请求，服务器接收请求后返回响应数据。创建 Node.js 应用步骤一、引入 required 模块我们使用 require 指令来载入 http 模块，并将实例化的 HTTP 赋值给变量 http，实例如下:var http = require(“http”);步骤二、创建服务器接下来我们使用 http.createServer() 方法创建服务器，并使用 listen 方法绑定 8888 端口。 函数通过 request, response 参数来接收和响应数据。实例如下，在你项目的根目录下创建一个叫 server.js 的文件，并写入以下代码：var http = require(‘http’); http.createServer(function (request, response) { // 发送 HTTP 头部 // HTTP 状态值: 200 : OK // 内容类型: text/plain response.writeHead(200, {&apos;Content-Type&apos;: &apos;text/plain&apos;}); // 发送响应数据 &quot;Hello World&quot; response.end(&apos;Hello World\\n&apos;); }).listen(8888); // 终端打印如下信息console.log(‘Server running at http://127.0.0.1:8888/&#39;);以上代码我们完成了一个可以工作的 HTTP 服务器。使用 node 命令执行以上的代码：node server.jsServer running at http://127.0.0.1:8888/cmdrun接下来，打开浏览器访问 http://127.0.0.1:8888/，你会看到一个写着 “Hello World”的网页。nodejs-helloworld分析Node.js 的 HTTP 服务器：第一行请求（require）Node.js 自带的 http 模块，并且把它赋值给 http 变量。接下来我们调用 http 模块提供的函数： createServer 。这个函数会返回 一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。","categories":[{"name":"JS","slug":"JS","permalink":"https://skiyubon.github.io/categories/JS/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://skiyubon.github.io/tags/Node-js/"}]}]}